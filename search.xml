<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[horovod多机多卡启动指南]]></title>
    <url>%2F2020%2F01%2F03%2Fhorovod%E5%A4%9A%E6%9C%BA%E5%A4%9A%E5%8D%A1%E5%90%AF%E5%8A%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[要使用horovod的多机多卡，需要有以下的3个先决条件 不同机器可以访问相同的文件：nfs 不同机器使用相同的训练环境: Docker 不同机器可以ssh交互：ssh 免密登录 假设现在要在两台服务器A和B上多机多卡跑horovod，A为主worker，下面介绍怎么准备horovod的启动条件。 NFS1234567891011121314151617181920212223242526272829303132# 在A上的操作#1. 安装nfs服务器sudo apt install nfs-kernel-server#2. 编写配置文件sudo vi /etc/exports#/etc/exports文件的内容如下/data1/share *(rw,sync,no_subtree_check,no_root_squash)#3. 创建共享目录sudo mkdir -p /data1/share#4. 重启nfs服务sudo service nfs-kernel-server restart#5. 常用命令工具：#在安装NFS服务器时，已包含常用的命令行工具，无需额外安装。#显示已经mount到本机nfs目录的客户端机器。sudo showmount -e localhost#将配置文件中的目录全部重新export一次！无需重启服务。sudo exportfs -rv#查看NFS的运行状态sudo nfsstat#查看rpc执行信息，可以用于检测rpc运行情况sudo rpcinfo#查看网络端口，NFS默认是使用111端口。sudo netstat -tu -4 123456789101112# 在B上的操作#1. 安装nfs客户端sudo apt install nfs-common#2. 查看NFS服务器上的共享目录sudo showmount -e A的ip#3. 创建本地挂载目录sudo mkdir -p /data1/share#4. 挂载共享目录sudo mount -t nfs A的ip:/data1/share /data1/share 这样就完成了nfs的挂载，两台服务器A和B都可以访问和读写 /data1/share 这个共同目录，并且目录内的东西会保持一致。以后horovod需要的训练代码和数据也将会存在这些路径之下，以便两台服务器都可以访问。 Docker分别在A和B服务器上通过docker建立容器，这里仅以在A上的操作为例，B的类似。 将用户加到docker的组 1sudo gpasswd -a user docker 加入后退出连接，重新ssh登录就可以不加sudo运行docker命令了。 pull docker 1docker pull horovod/horovod:0.18.2-tf2.0.0-torch1.3.0-mxnet1.5.0-py3.6-gpu 建立容器 这里需要注意要把上一步的共享目录映射进来 1nvidia-docker run -itd --net=host -v /data1:/data1 --name horovod --shm-size=126g horovod/horovod:0.18.2-tf2.0.0-torch1.3.0-mxnet1.5.0-py3.6-gpu bash 运行容器 1docker exec -it horovod bash ssh免密登录此时A和B应分别在horovod容器内。 这里踩了个坑，如果按照horovod的Docker教程, 创建容器时如果添加映射 share/ssh:/root/.ssh，就一直实现不了免密的登录，不添加映射反而可以免密登录了。 先在B服务器上开启ssh 12345678910111213#1. 修改sshd配置 vim /etc/ssh/sshd_config#2. 改动如下Port 12345PermitRootLogin yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys .ssh/authorized_keys2#3. 保存配置，启动sshd/usr/sbin/sshd#4. 查看ssh是否启动ps -ef | grep ssh#5. 修改root的密码passwd 在A服务器上创建秘钥并且免密登录到B 123456789#1. 生成秘钥ssh-keygen -t rsa#2. 在B上创建.ssh文件夹ssh -p 12345 B mkdir -p .ssh#3. 将公钥添加到B的authorized_keys里cat .ssh/id_rsa.pub | ssh -p 12345 B 'cat &gt;&gt; .ssh/authorized_keys'#测试是否可以免密登录ssh -p 12345 B 启动测试至此horovod的启动环境就搭好了，剩下的配套地修改训练代码可以参考horovod的docs去改。 这里以horovod的github为例测试一下是否可以正常启动多机多卡训练。以下操作在服务器A上进行。 将horovod的代码下载到共享文件，注意下tag跟docker对应的版本 1git clone -b v0.18.2 https://github.com/horovod/horovod.git 修改examples下的pytorch_imagenet_resnet50.py，将imagenet路径修改为自己的路径(应在/data1/share里)。 按照TensorboardX和tqdm (服务器B也要安装) 12pip install tensorboardXpip install tqdm 运行启动多机多卡命令，每个服务器各用4张卡 1horovodrun -np 8 -H localhost:4,B:4 -p 12345 python pytorch_imagenet_resnet50.py 分别查看A和B的显卡占用，是否多机多卡启动正常。]]></content>
      <categories>
        <category>Deeplearning</category>
      </categories>
      <tags>
        <tag>Deeplearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百面机器学习]]></title>
    <url>%2F2019%2F09%2F29%2F%E7%99%BE%E9%9D%A2%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"></content>
      <categories>
        <category>Deeplearning</category>
      </categories>
      <tags>
        <tag>Deeplearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[挑战程序设计竞赛]]></title>
    <url>%2F2019%2F09%2F13%2F%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[挑战程序设计竞赛 初出茅庐——初级篇搜索DFS从某个状态开始，不断地转移状态直至无法转移，然后回退到前一步的状态，继续转移到其他状态，如此不断重复，直至找到最终的解。 部分和 选出若干数，和恰好为k。 12345678910111213141516171819202122// 输入 int a[MAX_N]; int n, k;// 已经从前i项得到了和sum，然后对于i项之后的进行分支 bool dfs(int i, int sum) &#123; // 如果前n项都计算过了，则返回sum是否与k相等 if (i == n) return sum == k; // 不加上a[i]的情况 if (dfs(i + 1, sum)) return true; // 加上a[i]的情况 if (dfs(i + 1, sum + a[i])) return true; // 无论是否加上a[i]都不能凑成k就返回false return false;&#125;void solve() &#123; if (dfs(0, 0)) printf("Yes\n"); else printf("No\n"); &#125; Lake Counting (DFS一次就是消掉了一块积水) ​ 从任意的W开始，不停地把邻接的部分用’.’代替。1次DFS后与初始的这个W连接的所有W就都被替 换成了’.’，因此直到图中不再存在W为止，总共进行DFS的次数就是答案了。 12345678910111213141516171819202122232425262728293031323334353637383940// 输入 int N, M; char field[MAX_N][MAX_M + 1]; // 园子// 现在位置(x,y) void dfs(int x, int y) &#123; // 将现在所在位置替换为. field[x][y] = '.'; // 循环遍历移动的8个方向 for (int dx = -1; dx &lt;= 1; dx++) &#123; for (int dy = -1; dy &lt;= 1; dy++) &#123; // 向x方向移动dx，向y方向移动dy，移动的结果为（nx,ny） int nx = x + dx, ny = y + dy; // 判断(nx,ny)是不是在园子内，以及是否有积水 if (0 &lt;= nx &amp;&amp; nx &lt; N &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; M &amp;&amp; field[nx][ny] == 'W') dfs(nx, ny); &#125; &#125; return ;&#125;void solve() &#123; int res = 0; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; M; j++) &#123; if (field[i][j] == 'W') &#123; // 从有W的地方开始dfs dfs(i, j); res++; &#125; &#125; &#125; printf("%d\n", res);&#125; BFS​ 与深度优先搜索的不同之处在于搜索的顺序，宽度优先搜索总是先搜索距离初始状态近的状态。 也就是说，它是按照开始状态→只需1次转移就可以到达的所有状态→只需2次转移就可以到达的所有状态→…… ​ 深度优先用栈，宽度优先用队列 迷宫最短路径 ​ 宽度优先搜索按照距开始状态由近及远的顺序进行搜索，因此可以很容易地用来求最短路径、最少操作之类问题的答案。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const int INF = 100000000;// 使用pair表示状态时，使用typedef会更加方便一些 typedef pair&lt;int, int&gt; P;// 输入 char maze[MAX_N][MAX_M + 1]; // 表示迷宫的字符串的数组int N, M; int sx, sy; // 起点坐标 int gx, gy; // 终点坐标int d[MAX_N][MAX_M]; // 到各个位置的最短距离的数组// 4个方向移动的向量int dx[4] = &#123;1, 0, -1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;// 求从(sx, sy)到(gx, gy)的最短距离 // 如果无法到达，则是INFint bfs() &#123; queue&lt;P&gt; que; // 把所有的位置都初始化为INF for (int i = 0; i &lt; N; i++) for (int j = 0; j &lt; M; j++) d[i][j] = INF; // 将起点加入队列，并把这一地点的距离设置为0 que.push(P(sx, sy)); d[sx][sy] = 0; // 不断循环直到队列的长度为0 while (que.size()) &#123; // 从队列的最前端取出元素 P p = que.front(); que.pop(); // 如果取出的状态已经是终点，则结束搜索 if (p.first == gx &amp;&amp; p.second == gy) break; // 四个方向的循环 for (int i = 0; i &lt; 4; i++) &#123; // 移动之后的位置记为(nx, ny) int nx = p.first + dx[i], ny = p.second + dy[i]; // 判断是否可以移动以及是否已经访问过（d[nx][ny]!=INF即为已经访问过） if (0 &lt;= nx &amp;&amp; nx &lt; N &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; M &amp;&amp; maze[nx][ny] != '#' &amp;&amp; d[nx][ny] == INF) &#123; // 可以移动的话，则加入到队列，并且到该位置的距离确定为到p的距离+1 que.push(P(nx, ny)); d[nx][ny] = d[p.first][p.second] + 1; &#125; &#125; &#125; return d[gx][gy];&#125;void solve() &#123; int res = bfs(); printf("%d\n", res); &#125; 贪心 硬币问题 优先使用面值大的硬币 12345678……for(int i = 5; i &gt;= 0; i--)&#123; int t = min(A/V[i],C[i]); A-= t*V[i]; ans+=t;&#125;…… 区间调度问题 在可选的工作中，每次都去结束时间最早的工作 Fence Repair 木板的长度*节点的深度 ==&gt; 哈夫曼编码 动态规划 01背包 $memset(dp,-1,sizeof(dp))$ 按照1字节为单位对内存进行填充，-1每个二进制都为1。memset只能初始化为0或-1。 状态 $dp[i][j]$ ：从第i个物品开始挑选总重小于j的部分 递推 $dp[n][j] = 0$ $dp[i][j] = max(dp[i+1][j],dp[i+1][j-w[i]]+v[i])$ 完全背包 从01背包的选或不选转化为选多少件。 多重部分和 状态：$dp[i+1][j]$: 用前i种数加和得到j时第i种数最多剩余多少个（不能加和得到i的情况为-1）​ dp[i+1][j]=\begin{equation} \left\{ \begin{array}{**lr**} m_i & (dp[i][j] \geq 0) \\ -1 & (j]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TF2_Notes]]></title>
    <url>%2F2019%2F05%2F10%2FTF2-Notes%2F</url>
    <content type="text"><![CDATA[Keras 快速入门 构建好模型后，通过调用 compile 方法配置该模型的学习流程 1234567model = tf.keras.Sequential()model.add(layers.Dense(32, activation='relu'))model.add(layers.Dense(32, activation='relu'))model.add(layers.Dense(10, activation='softmax'))model.compile(optimizer=tf.keras.optimizers.Adam(0.001), loss=tf.keras.losses.categorical_crossentropy, metrics=[tf.keras.metrics.categorical_accuracy]) 函数式api ​ tf.keras.Sequential 模型是层的简单堆叠，无法表示任意模型。使用 Keras 函数式 API 可以构建复杂的模型拓扑，例如： 多输入模型， 多输出模型， 具有共享层的模型（同一层被调用多次）， 具有非序列数据流的模型（例如，残差连接）。 使用函数式 API 构建的模型具有以下特征： ​ 层实例可调用并返回张量。 输入张量和输出张量用于定义 tf.keras.Model 实例。 此模型的训练方式和 Sequential 模型一样。 12345678910111213input_x = tf.keras.Input(shape=(72,))# 层实例可调用并返回张量hidden1 = layers.Dense(32, activation='relu')(input_x)hidden2 = layers.Dense(16, activation='relu')(hidden1)pred = layers.Dense(10, activation='softmax')(hidden2)# 输入张量和输出张量用于定义 tf.keras.Model 实例model = tf.keras.Model(inputs=input_x, outputs=pred)model.compile(optimizer=tf.keras.optimizers.Adam(0.001), loss=tf.keras.losses.categorical_crossentropy, metrics=['accuracy'])model.fit(train_x, train_y, batch_size=32, epochs=5) 模型子类化(类似Pytorch) Init 创建层并将它们设置为类实例的属性 call 中定义前向传播 12345678910111213141516171819202122class MyModel(tf.keras.Model): def __init__(self, num_classes=10): super(MyModel, self).__init__(name='my_model') self.num_classes = num_classes self.layer1 = layers.Dense(32, activation='relu') self.layer2 = layers.Dense(num_classes, activation='softmax') def call(self, inputs): h1 = self.layer1(inputs) out = self.layer2(h1) return out def compute_output_shape(self, input_shape): shape = tf.TensorShape(input_shape).as_list() shape[-1] = self.num_classes return tf.TensorShape(shape)model = MyModel(num_classes=10)model.compile(optimizer=tf.keras.optimizers.RMSprop(0.001), loss=tf.keras.losses.categorical_crossentropy, metrics=['accuracy'])model.fit(train_x, train_y, batch_size=16, epochs=5) 自定义层 通过对 tf.keras.layers.Layer 进行子类化并实现以下方法来创建自定义层： build：创建层的权重。使用 add_weight 方法添加权重。 call：定义前向传播。 compute_output_shape：指定在给定输入形状的情况下如何计算层的输出形状。 或者，可以通过实现 get_config 方法和 from_config 类方法序列化层。 12345678910111213141516171819202122232425262728293031323334353637383940class MyLayer(layers.Layer): def __init__(self, output_dim, **kwargs): self.output_dim = output_dim super(MyLayer, self).__init__(**kwargs) def build(self, input_shape): shape = tf.TensorShape((input_shape[1], self.output_dim)) self.kernel = self.add_weight(name='kernel1', shape=shape, initializer='uniform', trainable=True) super(MyLayer, self).build(input_shape) def call(self, inputs): return tf.matmul(inputs, self.kernel) def compute_output_shape(self, input_shape): shape = tf.TensorShape(input_shape).as_list() shape[-1] = self.output_dim return tf.TensorShape(shape) def get_config(self): base_config = super(MyLayer, self).get_config() base_config['output_dim'] = self.output_dim return base_config @classmethod def from_config(cls, config): return cls(**config)model = tf.keras.Sequential([ MyLayer(10), layers.Activation('softmax')])model.compile(optimizer=tf.keras.optimizers.RMSprop(0.001), loss=tf.keras.losses.categorical_crossentropy, metrics=['accuracy'])model.fit(train_x, train_y, batch_size=16, epochs=5) Estimator Estimator API 用于针对分布式环境训练模型。它适用于一些行业使用场景，例如用大型数据集进行分布式训练并导出模型以用于生产 12345678model = tf.keras.Sequential([layers.Dense(10,activation='softmax'), layers.Dense(10,activation='softmax')])model.compile(optimizer=tf.keras.optimizers.RMSprop(0.001), loss='categorical_crossentropy', metrics=['accuracy'])estimator = tf.keras.estimator.model_to_estimator(model) keras 函数api 小型残差网络 1234567891011121314151617181920212223242526272829303132333435inputs = keras.Input(shape=(32,32,3), name='img')h1 = layers.Conv2D(32, 3, activation='relu')(inputs)h1 = layers.Conv2D(64, 3, activation='relu')(h1)block1_out = layers.MaxPooling2D(3)(h1)h2 = layers.Conv2D(64, 3, activation='relu', padding='same')(block1_out)h2 = layers.Conv2D(64, 3, activation='relu', padding='same')(h2)block2_out = layers.add([h2, block1_out])h3 = layers.Conv2D(64, 3, activation='relu', padding='same')(block2_out)h3 = layers.Conv2D(64, 3, activation='relu', padding='same')(h3)block3_out = layers.add([h3, block2_out])h4 = layers.Conv2D(64, 3, activation='relu')(block3_out)h4 = layers.GlobalMaxPool2D()(h4)h4 = layers.Dense(256, activation='relu')(h4)h4 = layers.Dropout(0.5)(h4)outputs = layers.Dense(10, activation='softmax')(h4)model = keras.Model(inputs, outputs, name='small resnet')model.summary()keras.utils.plot_model(model, 'small_resnet_model.png', show_shapes=True)(x_train, y_train), (x_test, y_test) = keras.datasets.cifar10.load_data()x_train = x_train.astype('float32') / 255x_test = y_train.astype('float32') / 255y_train = keras.utils.to_categorical(y_train, 10)y_test = keras.utils.to_categorical(y_test, 10)model.compile(optimizer=keras.optimizers.RMSprop(1e-3), loss='categorical_crossentropy', metrics=['acc'])model.fit(x_train, y_train, batch_size=64, epochs=1, validation_split=0.2) 自定义网络层 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# import tensorflow as tf# import tensorflow.keras as kerasclass MyDense(layers.Layer): def __init__(self, units=32): super(MyDense, self).__init__() self.units = units def build(self, input_shape): self.w = self.add_weight(shape=(input_shape[-1], self.units), initializer='random_normal', trainable=True) self.b = self.add_weight(shape=(self.units,), initializer='random_normal', trainable=True) def call(self, inputs): return tf.matmul(inputs, self.w) + self.b def get_config(self): return &#123;'units': self.units&#125;inputs = keras.Input((4,))outputs = MyDense(10)(inputs)model = keras.Model(inputs, outputs)config = model.get_config()new_model = keras.Model.from_config(config, custom_objects=&#123;'MyDense':MyDense&#125;)# 在自定义网络层调用其他网络层# 超参time_step = 10batch_size = 32hidden_dim = 32inputs_dim = 5# 网络class MyRnn(layers.Layer): def __init__(self): super(MyRnn, self).__init__() self.hidden_dim = hidden_dim self.projection1 = layers.Dense(units=hidden_dim, activation='relu') self.projection2 = layers.Dense(units=hidden_dim, activation='relu') self.classifier = layers.Dense(1, activation='sigmoid') def call(self, inputs): outs = [] states = tf.zeros(shape=[inputs.shape[0], self.hidden_dim]) for t in range(inputs.shape[1]): x = inputs[:,t,:] h = self.projection1(x) y = h + self.projection2(states) states = y outs.append(y) # print(outs) features = tf.stack(outs, axis=1) print(features.shape) return self.classifier(features)# 构建网络inputs = keras.Input(batch_shape=(batch_size, time_step, inputs_dim))x = layers.Conv1D(32, 3)(inputs)print(x.shape)outputs = MyRnn()(x)model = keras.Model(inputs, outputs)rnn_model = MyRnn()_ = rnn_model(tf.zeros((1, 10, 5))) 使用keras训练模型 模型构造、训练、测试 1234567891011121314151617181920212223242526272829303132333435# 模型构造inputs = keras.Input(shape=(784,), name='mnist_input')h1 = layers.Dense(64, activation='relu')(inputs)h1 = layers.Dense(64, activation='relu')(h1)outputs = layers.Dense(10, activation='softmax')(h1)model = keras.Model(inputs, outputs)# keras.utils.plot_model(model, 'net001.png', show_shapes=True)model.compile(optimizer=keras.optimizers.RMSprop(), loss=keras.losses.SparseCategoricalCrossentropy(), metrics=[keras.metrics.SparseCategoricalAccuracy()])# 载入数据(x_train, y_train), (x_test, y_test) = keras.datasets.mnist.load_data()x_train = x_train.reshape(60000, 784).astype('float32') /255x_test = x_test.reshape(10000, 784).astype('float32') /255x_val = x_train[-10000:]y_val = y_train[-10000:]x_train = x_train[:-10000]y_train = y_train[:-10000]# 训练模型history = model.fit(x_train, y_train, batch_size=64, epochs=3, validation_data=(x_val, y_val))print('history:')print(history.history)result = model.evaluate(x_test, y_test, batch_size=128)print('evaluate:')print(result)pred = model.predict(x_test[:2])print('predict:')print(pred) 多输入多输出模型 12345678910111213141516171819202122232425262728293031323334353637383940414243image_input = keras.Input(shape=(32, 32, 3), name='img_input')timeseries_input = keras.Input(shape=(None, 10), name='ts_input')x1 = layers.Conv2D(3, 3)(image_input)x1 = layers.GlobalMaxPooling2D()(x1)x2 = layers.Conv1D(3, 3)(timeseries_input)x2 = layers.GlobalMaxPooling1D()(x2)x = layers.concatenate([x1, x2])score_output = layers.Dense(1, name='score_output')(x)class_output = layers.Dense(5, activation='softmax', name='class_output')(x)model = keras.Model(inputs=[image_input, timeseries_input], outputs=[score_output, class_output])keras.utils.plot_model(model, 'multi_input_output_model.png' , show_shapes=True)# 可以为模型指定不同的loss和metricsmodel.compile( optimizer=keras.optimizers.RMSprop(1e-3), loss=[keras.losses.MeanSquaredError(), keras.losses.CategoricalCrossentropy()])# 还可以指定loss的权重model.compile( optimizer=keras.optimizers.RMSprop(1e-3), loss=&#123;'score_output': keras.losses.MeanSquaredError(), 'class_output': keras.losses.CategoricalCrossentropy()&#125;, metrics=&#123;'score_output': [keras.metrics.MeanAbsolutePercentageError(), keras.metrics.MeanAbsoluteError()], 'class_output': [keras.metrics.CategoricalAccuracy()]&#125;, loss_weight=&#123;'score_output': 2., 'class_output': 1.&#125;)# 可以把不需要传播的loss置0model.compile( optimizer=keras.optimizers.RMSprop(1e-3), loss=[None, keras.losses.CategoricalCrossentropy()])# Or dict loss versionmodel.compile( optimizer=keras.optimizers.RMSprop(1e-3), loss=&#123;'class_output': keras.losses.CategoricalCrossentropy()&#125;) 动态调整学习率 12345678910111213141516# 动态调整学习率initial_learning_rate = 0.1lr_schedule = keras.optimizers.schedules.ExponentialDecay( initial_learning_rate, decay_steps=10000, decay_rate=0.96, staircase=True)optimizer = keras.optimizers.RMSprop(learning_rate=lr_schedule)# 使用tensorboardtensorboard_cbk = keras.callbacks.TensorBoard(log_dir='./full_path_to_your_logs')model.fit(x_train, y_train, epochs=5, batch_size=64, callbacks=[tensorboard_cbk], validation_split=0.2) 自己构造训练和验证循环 (类Pytorch) 1234567891011121314151617181920212223242526272829303132# 构建一个全连接网络.inputs = keras.Input(shape=(784,), name='digits')x = layers.Dense(64, activation='relu', name='dense_1')(inputs)x = layers.Dense(64, activation='relu', name='dense_2')(x)outputs = layers.Dense(10, activation='softmax', name='predictions')(x)model = keras.Model(inputs=inputs, outputs=outputs)# 优化器.optimizer = keras.optimizers.SGD(learning_rate=1e-3)# 损失函数.loss_fn = keras.losses.SparseCategoricalCrossentropy()# 准备数据.batch_size = 64train_dataset = tf.data.Dataset.from_tensor_slices((x_train, y_train))train_dataset = train_dataset.shuffle(buffer_size=1024).batch(batch_size)# 自己构造循环for epoch in range(3): print('epoch: ', epoch) for step, (x_batch_train, y_batch_train) in enumerate(train_dataset): # 开一个gradient tape, 计算梯度 with tf.GradientTape() as tape: logits = model(x_batch_train) loss_value = loss_fn(y_batch_train, logits) grads = tape.gradient(loss_value, model.trainable_variables) optimizer.apply_gradients(zip(grads, model.trainable_variables)) if step % 200 == 0: print('Training loss (for one batch) at step %s: %s' % (step, float(loss_value))) print('Seen so far: %s samples' % ((step + 1) * 64)) 训练并验证 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 训练并验证# 获取模型inputs = keras.Input(shape=(784,), name='digits')x = layers.Dense(64, activation='relu', name='dense_1')(inputs)x = layers.Dense(64, activation='relu', name='dense_2')(x)outputs = layers.Dense(10, activation='softmax', name='predictions')(x)model = keras.Model(inputs=inputs, outputs=outputs)# sgd优化器optimizer = keras.optimizers.SGD(learning_rate=1e-3)# 分类损失函数loss_fn = keras.losses.SparseCategoricalCrossentropy()# 设定统计参数train_acc_metric = keras.metrics.SparseCategoricalAccuracy() val_acc_metric = keras.metrics.SparseCategoricalAccuracy()# 准备训练数据batch_size = 64train_dataset = tf.data.Dataset.from_tensor_slices((x_train, y_train))train_dataset = train_dataset.shuffle(buffer_size=1024).batch(batch_size)# 准备验证数据val_dataset = tf.data.Dataset.from_tensor_slices((x_val, y_val))val_dataset = val_dataset.batch(64)# 迭代训练for epoch in range(3): print('Start of epoch %d' % (epoch,)) for step, (x_batch_train, y_batch_train) in enumerate(train_dataset): with tf.GradientTape() as tape: logits = model(x_batch_train) loss_value = loss_fn(y_batch_train, logits) grads = tape.gradient(loss_value, model.trainable_variables) optimizer.apply_gradients(zip(grads, model.trainable_variables)) # 更新统计传输 train_acc_metric(y_batch_train, logits) # 输出 if step % 200 == 0: print('Training loss (for one batch) at step %s: %s' % (step, float(loss_value))) print('Seen so far: %s samples' % ((step + 1) * 64)) # 输出统计参数的值 train_acc = train_acc_metric.result() print('Training acc over epoch: %s' % (float(train_acc),)) # 重置统计参数 train_acc_metric.reset_states() # 用模型进行验证 for x_batch_val, y_batch_val in val_dataset: val_logits = model(x_batch_val) # 根据验证的统计参数 val_acc_metric(y_batch_val, val_logits) val_acc = val_acc_metric.result() val_acc_metric.reset_states() print('Validation acc: %s' % (float(val_acc),)) 添加自己构造的loss 123456789101112131415161718192021222324252627282930313233343536373839404142## 添加自己构造的loss, 每次只能看到最新一次训练增加的lossclass ActivityRegularizationLayer(layers.Layer): def call(self, inputs): self.add_loss(1e-2 * tf.reduce_sum(inputs)) return inputsinputs = keras.Input(shape=(784,), name='digits')x = layers.Dense(64, activation='relu', name='dense_1')(inputs)# Insert activity regularization as a layerx = ActivityRegularizationLayer()(x)x = layers.Dense(64, activation='relu', name='dense_2')(x)outputs = layers.Dense(10, activation='softmax', name='predictions')(x)model = keras.Model(inputs=inputs, outputs=outputs)logits = model(x_train[:64])print(model.losses)logits = model(x_train[:64])logits = model(x_train[64: 128])logits = model(x_train[128: 192])print(model.losses)# 将loss添加进求导中optimizer = keras.optimizers.SGD(learning_rate=1e-3)for epoch in range(3): print('Start of epoch %d' % (epoch,)) for step, (x_batch_train, y_batch_train) in enumerate(train_dataset): with tf.GradientTape() as tape: logits = model(x_batch_train) loss_value = loss_fn(y_batch_train, logits) # 添加额外的loss loss_value += sum(model.losses) grads = tape.gradient(loss_value, model.trainable_variables) optimizer.apply_gradients(zip(grads, model.trainable_variables)) # 每200个batch输出一次学习. if step % 200 == 0: print('Training loss (for one batch) at step %s: %s' % (step, float(loss_value))) print('Seen so far: %s samples' % ((step + 1) * 64)) 用keras构建自己的网络层 构建一个简单的网络层: 设置网络权重和输出到输入的计算过程 12345678910111213141516171819202122232425262728293031from __future__ import absolute_import, division, print_functionimport tensorflow as tftf.keras.backend.clear_session()import tensorflow.keras as kerasimport tensorflow.keras.layers as layers# 定义网络层就是：设置网络权重和输出到输入的计算过程class MyLayer(layers.Layer): def __init__(self, input_dim=32, unit=32): super(MyLayer, self).__init__() w_init = tf.random_normal_initializer() self.weight = tf.Variable(initial_value=w_init( shape=(input_dim, unit), dtype=tf.float32), trainable=True) b_init = tf.zeros_initializer() self.bias = tf.Variable(initial_value=b_init( shape=(unit,), dtype=tf.float32), trainable=True) def call(self, inputs): return tf.matmul(inputs, self.weight) + self.bias x = tf.ones((3,5))my_layer = MyLayer(5, 4)out = my_layer(x)print(out) tf.Tensor([[0.06709253 0.06818779 0.09926171 0.0179923 ] [0.06709253 0.06818779 0.09926171 0.0179923 ] [0.06709253 0.06818779 0.09926171 0.0179923 ]], shape=(3, 4), dtype=float32) 按上面构建网络层，图层会自动跟踪权重w和b，当然我们也可以直接用add_weight的方法构建权重 12345678910111213141516171819202122class MyLayer(layers.Layer): def __init__(self, input_dim=32, unit=32): super(MyLayer, self).__init__() self.weight = self.add_weight(shape=(input_dim, unit), initializer=keras.initializers.RandomNormal(), trainable=True) self.bias = self.add_weight(shape=(unit,), initializer=keras.initializers.Zeros(), trainable=True) def call(self, inputs): return tf.matmul(inputs, self.weight) + self.bias x = tf.ones((3,5))my_layer = MyLayer(5, 4)out = my_layer(x)print(out) tf.Tensor([[-0.10401802 -0.05459599 -0.08195674 0.13151655] [-0.10401802 -0.05459599 -0.08195674 0.13151655] [-0.10401802 -0.05459599 -0.08195674 0.13151655]], shape=(3, 4), dtype=float32) keras模型保存和序列化-]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deep Learning Book]]></title>
    <url>%2F2019%2F03%2F27%2FDeep-Learning-Book%2F</url>
    <content type="text"><![CDATA[Deep Learning第2章：线性代数 名词 内容 页码 广播(broadcasting) 隐式地复制向量b到很多位置 20 Hadamard 乘积 A \odot B 元素对应乘积 21 生成子空间 原始向量线性组合后所能抵达的点的集合 23 范数 向量的大小\Vert x \Vert_p = (\sum_{i} \vert x \vert^p )^{\frac{1}{p}} 24 正定 所有特征值都是正数的矩阵称为正定 27 迹运算 返回矩阵对角元素的和，Tr(A)=\sum_i A_{i,i},\quad Tr(A) = Tr(A^T) 29 行列式 将方阵$A$映射到实数的函数，行列式的绝对值可以用来衡量矩阵参与矩阵乘法后空间扩大或者缩小了多少 30]]></content>
      <categories>
        <category>Deeplearning</category>
      </categories>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sliding Window]]></title>
    <url>%2F2019%2F03%2F27%2FSliding-Window%2F</url>
    <content type="text"><![CDATA[双指针 begin 左指针，窗口起点 end 右指针，窗口终点 用map维护是否满足条件了 统计target的字符情况 1234for(auto c:target)&#123; m[c]++;&#125; end走一步，一个字符进窗口了 123m[c]--if(m[c]==0) counter--; begin走一步，一个字符离开窗口了 123m[c]++if(m[c]==1) counter++;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Problems]]></title>
    <url>%2F2019%2F03%2F23%2FLeetcode-Problems%2F</url>
    <content type="text"><![CDATA[032 Longest Valid Parentheses 给出一个只含括号字符串，求最长的括号匹配的字串长度。 ​ 一开始自己的想法是从左向右扫，利用一个栈，碰到左括号则进栈，碰到右括号且栈顶为左括号则此时匹配长度length加2，否则length重置为0，维护length的最大值。 但是，对于下面的两个case “()(()” ===&gt; 2 “()(())” ===&gt; 6 按照这个思路会把例子1算出4，显然不对。对于加粗的左括号，在例子1中需要重置length（加粗左括号是间隔点），在例子2中又不需要重置length（加粗左括号不是间隔点），所以什么时候重置length为0就比较棘手了，一直没想出来。 按照Dissusion的思路,只需要把index放进栈就可以了，用栈来记录所有的间隔点。 是左括号就把它的index进栈 是右括号就且栈顶对应的符号是左括号，则退栈，否则index进栈 匹配的都退栈退掉了，剩下在栈中的就说所有不能匹配的间隔点的index,根据这个算最大值。 自己错误的代码 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int longestValidParentheses(string s) &#123; if (s.size() &lt; 2) return 0; stack&lt;char&gt; S; int start = 0; int ans = 0; int length = 0; while (s[start] == ')')//去掉前缀')' &#123; start++; &#125; S.push(s[start]); for (int i = start + 1; i &lt; s.size(); ++i) &#123; char c = s[i]; if (c == '(') &#123; if (!S.empty()) &#123; ans = max(length, ans); length = 0; &#125; S.push(c); &#125; else if (c == ')') &#123; if (!S.empty() &amp;&amp; S.top() == '(') &#123; length += 2; S.pop(); &#125; else // top is ')' or null, is match &#123; ans = max(ans, length); length = 0; &#125; &#125; &#125; return max(length, ans); &#125;&#125;; AC的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243//记录断的位置class Solution&#123;public: int longestValidParentheses(string s) &#123; if (s.size() &lt; 2) return 0; stack&lt;int&gt; st; st.push(-1); for (int i = 0; i &lt; s.size(); ++i) &#123; char c = s[i]; if (c == '(') &#123; st.push(i); &#125; else //c==')' &#123; if (st.size() &gt; 1 &amp;&amp; s[st.top()] == '(') &#123; st.pop(); &#125; else &#123; st.push(i); &#125; &#125; &#125; st.push(s.size()); int ans = 0; int pre = st.top(); st.pop(); while (!st.empty()) &#123; ans = max(ans, pre - st.top() - 1); pre = st.top(); st.pop(); &#125; return ans; &#125; &#125;;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cs231n]]></title>
    <url>%2F2019%2F01%2F13%2Fcs231n%2F</url>
    <content type="text"><![CDATA[1.Image Classificationslides：Image Classification pipeline L1 与 L2（2范数，欧氏距离）距离 交叉验证把数据集分成n等份，分别把每一份作为验证集（寻找最优超参数），最后将结果平均。 linear classification notes SVM Loss L_i = \sum_{j\neq y_i} \max(0, s_j - s_{y_i} + \Delta) s_{y_i} 比s_j 大至少\Delta，则该项Loss为0\\ s_{y_i} - s_j > \Delta \Rightarrow s_{y_i} - s_j - \Delta > 0 \Rightarrow s_j - s_{y_i} + \Delta < 0Example: s=[13,−7,11], first class is the true class (i.e. yi=0) L_i = \max(0, -7 - 13 + 10) + \max(0, 11 - 13 + 10) We get zero loss for this pair because the correct class score (13) was greater than the incorrect class score (-7) by at least the margin 10 正则 Regularization​ Prevent the model from doing too well on training data：防止过拟合。 ​ 按照上述的SVM Loss公式，满足Loss为0的W有多个，最简单地，如果W0满足，那么 $W_0$ 满足，那么 $\lambda W_0$ 也将满足Loss为0。比如用$W_0$ 算出来的距离是15，那么用$2W_0$ 算出来的就是30，依旧大于margin,所以Loss为0. ​ 所以，为了不让所有 $\lambda W0$ 都满足Loss为0，可以引入一个正则项，比较常使用的L2正则：$R(W) = \sum_k\sum_l W{k,l}^2$ ，即把W矩阵的各个数字平方都加起来也作为Loss的一部分，这样可以确保W的唯一性。所以加上正则后的SVM Loss应该为：L = \underbrace{ \frac{1}{N} \sum_i L_i }_\text{data loss} + \underbrace{ \lambda R(W) }_\text{regularization loss} \\\\ ​ 展开后为: ​ L = \frac{1}{N} \sum_i \sum_{j\neq y_i} \left[ \max(0, f(x_i; W)_j - f(x_i; W)_{y_i} + \Delta) \right] + \lambda \sum_k\sum_l W_{k,l}^2 Softmax Loss​ SVM 和 Softmax是两大常见的分类器。 SVM: $f(x_i,W)$ 的输出是未经校准且可能难以解释，Use max-margin loss Softmax：直观输出（归一化类概率）并且还具有概率解释, Use cross-entropy loss $Li = -\log\left(\frac{e^{f{yi}}}{ \sum_j e^{f_j} }\right) \hspace{0.5in} \text{or equivalently} \hspace{0.5in} L_i = -f{y_i} + \log\sum_j e^{f_j}$ ​ SVM计算的trick，加一个C参数防止e指数后爆炸： ​ $\frac{e^{f{y_i}}}{\sum_j e^{f_j}} = \frac{Ce^{f{yi}}}{C\sum_j e^{f_j}} = \frac{e^{f{y_i} + \log C}}{\sum_j e^{f_j + \log C}}$ ​ 关于C的选择：$\log C = -\max_j f_j$, 使得 加了$C$ 的$f$ 的最大值是0。 ​ SVM vs. Softmax: 2.Loss Functions and Optimizationslides：Loss Functions and OptimizationSoftmax Classifier 如果分类器出来的分数大家都差不多相等，那么Softmax的Loss为 $logC$，C是类别数目。 Optimization 在多个维度中，梯度是沿每个维度的（偏导数）的向量 optimization notes Mini-batch gradient descent 批量梯度下降 没必要每张图片计算一个梯度，而是一批图片计算Loss得到一个梯度进行下降。 123456# Vanilla Minibatch Gradient Descentwhile True: data_batch = sample_training_data(data, 256) # sample 256 examples weights_grad = evaluate_gradient(loss_fun, data_batch, weights) weights += - step_size * weights_grad # perform parameter update batch的大小一般是2的整数次幂，因为矢量化操作实现在输入大小为2的情况下工作得更快。 3.Introduction to Neural Networksslides: Backpropagation and Neural NetworksBackpropagation 反向传播 简单的图示 梯度回传模式 加法：梯度都分给两个输入 max: 梯度路由给最大值 乘法：把两个input梯度交换 矩阵运算的梯度回传 Neural Networks 激活函数 Sigmoid,tanh,ReLU,Leaky ReLU,Maxout,ELU backprop notes Problem statement We are given some function $f(x)$ where $x$ is a vector of inputs and we are interested in computing the gradient of $f$ at $x$ (i.e. $\nabla f(x)$). sigmoid 导数 \sigma(x) = \frac{1}{1+e^{-x}} \\\\ \rightarrow \hspace{0.3in} \frac{d\sigma(x)}{dx} = \frac{e^{-x}}{(1+e^{-x})^2} = \left( \frac{1 + e^{-x} - 1}{1 + e^{-x}} \right) \left( \frac{1}{1+e^{-x}} \right) = \left( 1 - \sigma(x) \right) \sigma(x) 4.Backpropagationslides: Backpropagation and Gradients 5.Convolutional Neural Networksslides:Convolutional Neural Networks ConvNet notes]]></content>
      <categories>
        <category>Computervision</category>
      </categories>
      <tags>
        <tag>Computervision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mathematics for Machine Learning: Linear Algebra]]></title>
    <url>%2F2018%2F10%2F16%2FMathematics-for-Machine-Learning-Linear-Algebra%2F</url>
    <content type="text"><![CDATA[1. Introduction to Linear Algebra and to Mathematics for Machine LearningThe relationship between machine learning, linear algebra, and vectors and matrices 格拉姆-施密特正交化 \boldsymbol{\beta}_1 = \boldsymbol{v}_1,\quad \boldsymbol{\eta}_1 = {\boldsymbol{\beta}_1 \over \|\boldsymbol{\beta}_1\|} \boldsymbol{\beta}_2 = \boldsymbol{v}_2-\langle \boldsymbol{v}_2, \boldsymbol{\eta}_1 \rangle \boldsymbol{\eta}_1, \quad \boldsymbol{\eta}_2 = {\boldsymbol{\beta}_2 \over \|\boldsymbol{\beta}_2\|} \boldsymbol{\beta}_3 = \boldsymbol{v}_3 - \langle \boldsymbol{v}_3, \boldsymbol{\eta}_1 \rangle \boldsymbol{\eta}_1 - \langle \boldsymbol{v}_3, \boldsymbol{\eta}_2 \rangle \boldsymbol{\eta}_2 ,\quad \boldsymbol{\eta}_3 = {\boldsymbol{\beta}_3 \over \|\boldsymbol{\beta}_3\|} \vdots \boldsymbol{\beta}_n = \boldsymbol{v}_n - \sum_{i=1}^{n-1}\langle \boldsymbol{v}_n, \boldsymbol{\eta}_i \rangle \boldsymbol{\eta}_i,\quad \boldsymbol{\eta}_n = {\boldsymbol{\beta}_n\over\|\boldsymbol{\beta}_n\|}]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pytorch Tutorial Notes]]></title>
    <url>%2F2018%2F09%2F05%2FPytorch%20Tutorial%20Notes%2F</url>
    <content type="text"><![CDATA[Input Pipeline 12# dataset =&gt; loader# torchvision.datasets =&gt; torch.utils.data.DataLoader Train &amp;&amp; Val Diff 12345678#train = true of falsetrain_dataset = torchvision.datasets.MNIST(root='../data/', train=True, transform=transforms.ToTensor(), download=True)val_dataset = torchvision.datasets.MNIST(root='../data/', train=False, transform=transforms.ToTensor()) torch.max ‘s return : first is the max value,second is the index 计算准确率 1correct += (predicted == labels).sum().item() Output size of Conv \dfrac {W-F+2p}{S}+1 Summary. To summarize, the Conv Layer: Accepts a volume of size W_1 \times H_1 \times D_1 Requires four hyperparameters: Number of filters K, their spatial extent F, the stride S, the amount of zero padding P. Produces a volume of sizeW2×H2×D2 where: W_2 = (W_1 - F + 2P)/S + 1 H_2 = (H_1 - F + 2P)/S + 1 D2=K With parameter sharing, it introduces F \cdot F \cdot D_1 weights per filter, for a total of (F \cdot F \cdot D_1) \cdot Kweights and K biases. In the output volume, the d-th depth slice (of size W2×H2) is the result of performing a valid convolution of the d-th filter over the input volume with a stride of S, and then offset by d-th bias.]]></content>
  </entry>
  <entry>
    <title><![CDATA[颜值打分Summary]]></title>
    <url>%2F2018%2F06%2F09%2F%E9%A2%9C%E5%80%BC%E6%89%93%E5%88%86Summary%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Computer Vision</category>
      </categories>
      <tags>
        <tag>Computer Vision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常trick]]></title>
    <url>%2F2018%2F04%2F20%2F%E6%97%A5%E5%B8%B8trick%2F</url>
    <content type="text"><![CDATA[日常trick numpy 矩阵正则化 1234567891011121314151617181920import numpy as npfrom numpy import linalg as LAMat = np.matrix([[1, 2], [3, 4]])print(Mat)'''[[1 2] [3 4]]'''norms = LA.norm(Mat, axis=1)print(norms)'''[ 2.23606798 5. ]'''Mat_norm = Mat / norms[:, np.newaxis]print(Mat_norm)'''[[ 0.4472136 0.89442719] [ 0.6 0.8 ]]''' CmakeCache与Cmake冲突报错的时候，直接删除CmakeCache就好了 error while loading shared libraries: libevent-1.4.so.2 动态库找不到 如果共享库文件安装到了/lib或/usr/lib目录下, 那么需执行一下ldconfig命令 cmake :command not found 在终端执行 命令：export PATH=/opt/cmake/bin:$PATH JupyterNotebook 创建conda环境 123conda install ipykernelsource activate env_namepython -m ipykernel install --user --name env_name --display-name "Python(env_name)" Linux查看文件夹大小 1du -sh * 批量删除空文件夹 1find -type d -empty | xargs -n 1 rm -rf c++ argsort 1234567891011121314template&lt;typename T&gt;vector&lt;size_t&gt; sort_indexes(const vector&lt;T&gt; &amp;v)&#123; // initialize original index locations vector&lt;size_t&gt; idx(v.size()); iota(idx.begin(), idx.end(), 0); // sort indexes based on comparing values in v sort(idx.begin(), idx.end(), [&amp;v](size_t i1, size_t i2) &#123; return v[i1] &gt; v[i2]; &#125;); return idx;&#125; c++： can’t have non-default parameters after your default parameters begin 1234567891011(X) int get_result(caffe1s::Net&lt;DType&gt; *pNet, std::vector &lt;FaceDetector::BoundingBox&gt; res, Response &amp;rsp, std::string &amp;msg, const int topk, const float scaledetect, const int inW, const int inH, const int inC, const int frame_idx, const int64_t pts, const cv::Mat inputMat, const std::string model_dir, int num = 0, std::string savePath = "", const cv::Mat save_mat);(√)int get_result(caffe1s::Net&lt;DType&gt; *pNet, std::vector &lt;FaceDetector::BoundingBox&gt; res, Response &amp;rsp, std::string &amp;msg, const int topk, const float scaledetect, const int inW, const int inH, const int inC, const int frame_idx, const int64_t pts, const cv::Mat inputMat, const cv::Mat save_mat, const std::string model_dir, int num = 0, std::string savePath = ""); ls 按数字大小而非字典序排序 1ls | xargs stat -c "%n" | sort -n 进程假死跟踪 1python -m trace --trace python_file_path 多进程下载时进程假死问题 123456import socket# Set the default timeout in secondstimeout = 20socket.setdefaulttimeout(timeout)...]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指Offer》笔记]]></title>
    <url>%2F2018%2F03%2F20%2F%E3%80%8A%E5%89%91%E6%8C%87Offer%E3%80%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[剑指Offer Chapter 1：面试的流程 一定要在代码开头处考虑边界条件，特殊输入（空指针，空字符串），错误处理等意外情况。 Chapter 2：面试需要的基础知识 sizeof(空类型) ==1 而非0，因为空类型也需要占用一定的空间，否则无法使用该实例。 如果上述空类型加了构造函数和虚构函数，再求sizeof还是1。因为构造函数和虚构函数只需要知道函数地址就可以了。 如果上述构造函数和虚构函数是虚函数，则编译器会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针。在32位机器，一个指针占4个字节，即sizeof得到4，在64位上则得到8。 c++不允许复制构造函数传值参数：A(A other) =&gt; A(const A&amp; other) vector每次扩容时，新的容量都是前一次的两倍，使用动态数组要尽量减少改变数组容量大小的次数。 12345678910111213int GetSize(int data[])&#123; return sizeof(data);&#125;int main()&#123; int data1[]=&#123;1,2,3,4,5&#125;; int size1=sizeof(data1);//5*4=20 int* data2 = data1; int size2 = sizeof(data2);//4 data2虽然指向数组第一个，但本质仍为指针 int size3 = GetSize(data1);//4 退化为指针&#125; 123456789int main()&#123; char str1 [] = "Hello world!"; char str2 [] = "Hello world!"; // str1 != str2 不同的指针 char* str3 = "Hello world!"; char* str4 = "Hello world!"; //str3==str4 都指向"Hello world!"这个常量地址&#125; 使用辅助空间实现O(n)排序 =&gt; timesOfAges[age] ++; ​ 整数中1出现的次数（从1到n整数中1出现的次数）​ 统计n这个数每一位上数字恰好为1的时候有多少种可能，最后把所有位数的可能性累加得到答案。 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; int factor = 1; int left, right;//left的最后一位是1的可能数 int ans = 0, count; int leftRight;//left的最后一位 left = n / factor; right = n % factor; while (left &gt; 0) &#123; leftRight = left % 10; if (leftRight &gt; 1) &#123; count = (left / 10 + 1) * factor; &#125; else if (leftRight == 1) &#123; count = left / 10 * factor + (right + 1); &#125; else &#123; count = left / 10 * factor; &#125; ans += count; factor *= 10; left = n / factor; right = n % factor; &#125; return ans; &#125;&#125;; ​ 把数组排成最小的数自定义排序的compare，到底是s1放前面比较小还是s2放前面比较小。注意比较函数得用static。因为需要给全局得sort调用。 123456789101112131415161718192021222324252627282930//// Created by cpz on 2018/1/24.//#include "head.h"class Solution &#123;public: string PrintMinNumber(vector&lt;int&gt; numbers) &#123; vector&lt;string&gt; strs; string ans = ""; for (auto i:numbers) &#123; strs.push_back(to_string(i)); &#125; sort(strs.begin(), strs.end(), compare); for (auto i:strs) ans += i; return ans; &#125; static bool compare(string str1, string str2) &#123; string s1 = str1 + str2, s2 = str2 + str1; if (s1 &lt; s2) return true; else return false; &#125;&#125;; ​ 丑数 把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 vector新加进来的数一定是前面的某个数*2，或者*3，或者*5得来的！ 123456789101112131415161718192021222324class Solution &#123;public: int GetUglyNumber_Solution(int index) &#123; if (index &lt; 1) return 0; vector&lt;int&gt; v; v.push_back(1); int i = 0, j = 0, k = 0; while (v.size() &lt; index) &#123; v.push_back(Min(v[i] * 2, v[j] * 3, v[k] * 5)); if (v.back() == v[i] * 2) i++; if (v.back() == v[j] * 3) j++; if (v.back() == v[k] * 5) k++; &#125; return v.back(); &#125; int Min(int i, int j, int k) &#123; return min(i, min(j, k)); &#125;&#125;; ​ 数组中的逆序对 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 ​ 比较难的一道题了，想了好久！O（N^2）肯定过不了，没想到是归并排序的变种。把原数组分为左右两部分，那么总的逆序对会等于，左边数组的逆序数对+右边数组的逆序数对+一个数在左一个数在右的逆序数对，即inv = inv(left) + inv(right) + inv(merge)。因为在归并的时候，左右数组已经有序了，所以一个数在左边（记为a[i]），一个数在右边（记为a[j]）的可能数为：(mid - i + 1)。 ​ 先看一下单纯的归并排序。 1234567891011121314151617181920212223242526272829303132333435363738394041//// Created by cpz on 2018/1/24.//#include "head.h"class Solution &#123;public: void mergeSort(vector&lt;int&gt; &amp;data, int start, int end) &#123; int mid = (start + end) / 2; if (end &gt; start) &#123; mergeSort(data, start, mid); mergeSort(data, mid + 1, end); merge(data, start, mid, end); &#125; &#125; void merge(vector&lt;int&gt; &amp;data, int start, int mid, int end) &#123; vector&lt;int&gt; temp; int i = start, j = mid + 1; int count = end - start + 1; while (count) &#123; if (i &gt; mid) temp.push_back(data[j++]); else if (j &gt; end) temp.push_back(data[i++]); else if (data[i] &lt; data[j]) temp.push_back(data[i++]); else//data[i] &gt; data[j] temp.push_back(data[j++]); count--; &#125; for (int k = start; k &lt;= end; ++k) &#123; data[k] = temp[k - start]; &#125; &#125;&#125;; ​ ​ ​ 再看可以统计逆序数对的归并排序，改变的代码行用diff注释。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//// Created by cpz on 2018/1/24.//#include "head.h"class Solution &#123;public: int InversePairs(vector&lt;int&gt; data) &#123; return mergeSort(data, 0, data.size() - 1); &#125; int mergeSort(vector&lt;int&gt; &amp;data, int start, int end) &#123; int inv = 0;//diff int mid = (start + end) / 2; if (end &gt; start) &#123; inv += mergeSort(data, start, mid);//diff inv += mergeSort(data, mid + 1, end);//diff inv += merge(data, start, mid, end);//diff &#125; return inv;//diff &#125; int merge(vector&lt;int&gt; &amp;data, int start, int mid, int end) &#123; int inv = 0;//diff vector&lt;int&gt; temp; int i = start, j = mid + 1; int count = end - start + 1; while (count) &#123; if (i &gt; mid) temp.push_back(data[j++]); else if (j &gt; end) temp.push_back(data[i++]); else if (data[i] &lt; data[j]) temp.push_back(data[i++]); else//data[i] &gt; data[j] &#123; inv += (mid - i + 1) ;//diff temp.push_back(data[j++]); &#125; count--; &#125; for (int k = start; k &lt;= end; ++k) &#123; data[k] = temp[k - start]; &#125; return inv;//diff &#125;&#125;; ​]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树的后序遍历序列]]></title>
    <url>%2F2018%2F01%2F23%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 ​ 其实也是利用递归的方法求解，但是刚开始少了对边界（输入数组为空）的处理，导致一直WA！！实在不应该。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution &#123;public: bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123; if (!sequence.size())//一开始少了这句，一直报错！ return false; for (auto i:sequence) nums.push_back(i); int len = sequence.size(); return VerifySquenceOfBST(0, len - 1); &#125; bool VerifySquenceOfBST(int i, int j) &#123; if (i == j) return true; //root is s[j] int root = nums[j]; int l = -1;//l第一个比root小的 for (int k = j - 1; k &gt;= i; --k) &#123; if (nums[k] &lt; root) &#123; l = k; break; &#125; &#125; if (l == j - 1)//right is null &#123; return isAllLeft(i, j) &amp;&amp; VerifySquenceOfBST(i, j - 1); &#125; else if (l == -1) // left is null &#123; return isAllRight(i, j) &amp;&amp; VerifySquenceOfBST(i, j - 1); &#125; else//left and right are both not null &#123; return isBST(i, j, l) &amp;&amp; VerifySquenceOfBST(i, l) &amp;&amp; VerifySquenceOfBST(l + 1, j - 1); &#125; &#125; bool isAllLeft(int i, int j) //[i..j-1] &lt; [j] &#123; for (int k = i; k &lt; j; ++k) &#123; if (nums[k] &gt; nums[j]) return false; &#125; return true; &#125; bool isAllRight(int i, int j) //[i..j-1] &gt; [j] &#123; for (int k = i; k &lt; j; ++k) &#123; if (nums[k] &lt; nums[j]) return false; &#125; return true; &#125; bool isBST(int i, int j, int k) //[i..k..j] k是第一个比nums[j]小的 &#123; int root = nums[j]; for (int l = i; l &lt;= k; ++l) &#123; if (nums[l] &gt; root) return false; &#125; for (int m = k + 1; m &lt; j; ++m) &#123; if (nums[m] &lt; root) return false; &#125; return true; &#125; vector&lt;int&gt; nums;&#125;;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找小结]]></title>
    <url>%2F2018%2F01%2F04%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[​ 最近和浩博讨论了下几道关于二分查找的题目。正好做一下总结，方便下一次能够快速手写出二分的算法。 ​ 其实，二分查找，可以用下图简单表示流程。 ​ 最基本的二分查找：在一个递增的序列查找某个值。 1234567891011121314int len = nums.size(); int low = 0, high = len - 1; int mid; while (low &lt;= high) &#123; mid = low + (high - low) / 2; if (nums[mid] == target) return true; else if (nums[mid] &gt; target) high = mid - 1; else low = mid + 1; &#125; return false; ​ LeetCode 34. Search for a Range Given an array of integers sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. For example,Given [5, 7, 7, 8, 8, 10] and target value 8,return [3, 4]. ​ 找出相同元素的上界和下界索引。 ​ 跟基本二分相比，就是要改变判断是否找到了的条件，不再是简单的a[mid] == target 就可以搞定的了。所以就手写了lowMatch 和 highMatch两个辅助函数来判断是否找到要找的上界和下界。以及思考如果这一回没找到接下来应该向左走还是向右走的问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt; &amp;nums, int target) &#123; vector&lt;int&gt; ans; int low = 0, high = nums.size() - 1; int mid; int ans1 = -1, ans2 = -1; while (low &lt;= high)//找最低 &#123; mid = (low + high) / 2; if (lowMatch(nums, target, mid)) &#123; ans1 = mid; break; &#125; else if (nums[mid] &lt; target) low = mid + 1; else// nums[mid]&gt;=target high = mid - 1;//即使相等，也一定在左边找 &#125; low = 0, high = nums.size() - 1; while (low &lt;= high)//找最高 &#123; mid = (low + high) / 2; if (highMatch(nums, target, mid)) &#123; ans2 = mid; break; &#125; else if (nums[mid] &lt;= target)//由上一个条件，即使跟target相等也不符合了 low = mid + 1; else //nums[mid]&gt;target high = mid - 1;//mid有可能是解 &#125; ans.push_back(ans1); ans.push_back(ans2); return ans; &#125; bool lowMatch(vector&lt;int&gt; &amp;nums, int target, int i) &#123; if (nums[i] != target) return false; if (i == 0)//第0个肯定是最左边的 return true; else if (nums[i] != nums[i - 1]) return true; return false; &#125; bool highMatch(vector&lt;int&gt; &amp;nums, int target, int i) &#123; if (nums[i] != target) return false; if (i == nums.size() - 1)//最后一个肯定是最右边的 return true; else if (nums[i] != nums[i + 1]) return true; return false; &#125;&#125;; ​ 其实这道题用STL模板库的lower_bound和upper_bound会更加简洁，但也少了锻炼自己手写二分的能力。(一开始就是用STL做的0-0) 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt;::iterator low, up; low = lower_bound(nums.begin(), nums.end(), target); up = upper_bound(nums.begin(), nums.end(), target); vector&lt;int&gt; ans; if (!binary_search(nums.begin(),nums.end(),target)) &#123; ans.push_back(-1); ans.push_back(-1); &#125; else &#123; ans.push_back(low - nums.begin()); ans.push_back(up - nums.begin() - 1); &#125; return ans; &#125;&#125;; LeetCode 153. Find Minimum in Rotated Sorted Array Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. You may assume no duplicate exists in the array. ​ 一个本来有序的数组旋转了一下，变得整体无序，部分有序了。在这样的一个旋转后的数组里查找最小值。 ​ 本质上还是可以用二分来做。就是在思考判断是否找到isFind以及向左走还是向右走的时候需要再加以修改。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; rotateArray) &#123; if (!rotateArray.size()) return 0; if (rotateArray.size() == 1) return rotateArray[0]; int len = rotateArray.size(); if (rotateArray[0] &lt; rotateArray[len - 1])//没有旋转 return rotateArray[0]; int low = 0, high = len - 1; int mid; while (low &lt;= high) &#123; mid = (low + high) / 2; if (isFind(rotateArray, mid)) return rotateArray[mid]; else if (rotateArray[mid] &gt;= rotateArray[0]) low = mid + 1; else high = mid - 1; &#125; return 0; &#125; bool isFind(vector&lt;int&gt; nums, int index) &#123; if (index == nums.size() - 1) return nums[index] &lt; nums[index - 1]; else if (index == 0) return nums[index] &lt; nums[nums.size() - 1]; else return nums[index] &lt; nums[index + 1] &amp;&amp; nums[index] &lt; nums[index - 1]; &#125;&#125;; LeetCode 154. Find Minimum in Rotated Sorted Array II Follow up for “Find Minimum in Rotated Sorted Array”:What if duplicates are allowed? Would this affect the run-time complexity? How and why? Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. The array may contain duplicates. ​ 相比上一道题就是只加了一个条件：允许重复值。但是这时候我就按照我自己的二分查找思路以及找不到如何做了。因为在a[mid] == a[0] 的时候你可以往左走，也可以往右走。根本二分不了。看了解答才发现可以用high = high - 1 来缩小查找的范围，把二分log(n)变成了O(n)的了。 123456789101112131415161718192021222324class Solution &#123;public: int findMin(vector&lt;int&gt; &amp;array) &#123; int low = 0; int high = array.size() - 1; int mid; while (low &lt; high) &#123; mid = low + (high - low) / 2; if (array[mid] &gt; array[high])//最小值一定在mid右边 &#123; low = mid + 1; &#125; else if (array[mid] == array[high])//最小值有可能在mid左边,也有可能在右边 &#123; high = high - 1;//去掉重复的,缩减范围 &#125; else//array[mid]&lt;array[high] =&gt; mid右边是单调,mid是右边最小得数,也可能是左边最小的数,所以high = mid,而非high = mid-1 &#123; high = mid; &#125; &#125; return array[high]; &#125;&#125;; ​ 但是后来我又用最笨的O(n)查找的算法提交了以下发，发现耗时更短。上面的是12ms，用下面的线性查找反而是6ms。性能提升了一倍。所以，可能是有重复还不如不用二分，因为最小值可能在mid左边也有可能在右边，并不能缩减范围，用线性查找吧。 123456789101112class Solution &#123;public: int findMin(vector&lt;int&gt; &amp;array) &#123; int minNum = INT32_MAX; for (auto i:array) &#123; minNum = min(minNum, i); &#125; return minNum; &#125;&#125;; ​ 完！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[172. Factorial Trailing Zeroes]]></title>
    <url>%2F2017%2F12%2F21%2F172-Factorial-Trailing-Zeroes%2F</url>
    <content type="text"><![CDATA[Given an integer n, return the number of trailing zeroes in n!. Note: Your solution should be in logarithmic time complexity. 题意：找出n!的后缀零（结尾有多少个0）。 是在高体课上想的这道题，能想到其实后缀0就是由10来的，而10又是由25来的，而能分解出2的有好多，所以问题就转变成了：*n！能分解出多少个5。 但是到了这就基本卡在这里了，想不通怎么处理可以分解出多个5的情况，比如25和50，甚至还想着打表找规律。 1234567891011121314class Solution &#123;public: int trailingZeroes(int n) &#123; int ans = 0; int cnt = 0; for (long long i = 5; n / i &gt; 0; i *= 5) &#123; cnt = n / i; ans += cnt; &#125; return ans; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10. Regular Expression Matching]]></title>
    <url>%2F2017%2F12%2F18%2F10-Regular-Expression-Matching%2F</url>
    <content type="text"><![CDATA[Implement regular expression matching with support for &#39;.&#39; and &#39;*&#39;. 1234567891011121314151617&gt; &apos;.&apos; Matches any single character.&gt; &apos;*&apos; Matches zero or more of the preceding element.&gt;&gt; The matching should cover the entire input string (not partial).&gt;&gt; The function prototype should be:&gt; bool isMatch(const char *s, const char *p)&gt;&gt; Some examples:&gt; isMatch(&quot;aa&quot;,&quot;a&quot;) → false&gt; isMatch(&quot;aa&quot;,&quot;aa&quot;) → true&gt; isMatch(&quot;aaa&quot;,&quot;aa&quot;) → false&gt; isMatch(&quot;aa&quot;, &quot;a*&quot;) → true&gt; isMatch(&quot;aa&quot;, &quot;.*&quot;) → true&gt; isMatch(&quot;ab&quot;, &quot;.*&quot;) → true&gt; isMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → true&gt; ​ 题意：正则匹配，判断p是否匹配s。其中’.’匹配任意单个字符，’*’匹配0个或多个的前一字符。 ​ 其实前两个月就刷了这道题，当时虽然也看了题解但是并不能很好理解，甚至看不懂题目的匹配原则。正值昨天浩博来问，发现大体能看懂，就昨晚再重新推导并重写了下代码，AC了。 ​ 首先定义状态： 1dp[i][j] := s串的前i个字符和p串的前j个字符是否能匹配 ​ 先初始化dp表，处理当s为空串的情况。 123456789dp[0][0] = true;//都为空是匹配的 dp[0][1] = false;//s为空，那么p只有一个字符的话是无论如何不能匹配的 for (int j = 2; j &lt;= n; ++j)//s为空 &#123; if (p[j - 1] == '*')//a*只能出现0次，匹配空串，因为s为空 dp[0][j] = dp[0][j - 2]; else//p[j]为.或* dp[0][j] = false; &#125; ​ 接下来就是推导状态转移了！状态转移的推导主要是根据模式串（p）的最后一个字符（p[j-1]）来决定的。这里我们先看一下这个比较烦人的‘*’号。 1‘*’代表前一字符可以重复0次或者多次（&gt;=1）。 ​ 怎么处理好重复多次应该是这道题最难的地方，根据Discuss里的大佬的提示，可以做如下的处理： 假设‘*’的前一个字符为a,即‘a*’ 重复0次 最好处理了，只需要判断p串里a符号前的子串能否匹配s串 =&gt; dp[i][j] = dp[i][j-2] 重复多次 用了一个技巧，把模式串变成了a*a，这样只需要判断： s串的最后一个字符是否和a相等 判断dp[i-1][j]是否为true(即，s[0,1,2,3,…,i-2]是否与p[0,1,2,…,j-1] 匹配) 下面用s = “aa” 以及 p=”a*“ 推算一下“*”是怎么匹配两次的。 搞明白“*”的多次匹配之后，接下来就进入正式推导了，dp[i][j]的取值主要看p串的最后一个字符（即p[j-1]）。 Code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//// Created by chaopengz on 2017/9/25.//#include "head.h"class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(m + 1, vector&lt;bool&gt;(n + 1, false)); dp[0][0] = true; dp[0][1] = false;//s为空，那么p只有一个字符的话是无论如何不能匹配的 for (int j = 2; j &lt;= n; ++j)//s为空 &#123; if (p[j - 1] == '*')//a*只能出现0次，因为s为空 dp[0][j] = dp[0][j - 2]; else//p[j]为.或* dp[0][j] = false; &#125; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (p[j - 1] == '*')//x*出现0次或者多次 &#123; if (p[j - 2] == '.') &#123; dp[i][j] = dp[i][j - 2] || dp[i - 1][j]; &#125; else &#123; dp[i][j] = dp[i][j - 2] || (s[i - 1] == p[j - 2] &amp;&amp; dp[i - 1][j]); &#125; &#125; else if (p[j - 1] == '.') &#123; dp[i][j] = dp[i - 1][j - 1]; &#125; else &#123; dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1]); &#125; &#125; &#125; return dp[m][n]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[279. Perfect Squares]]></title>
    <url>%2F2017%2F12%2F04%2F279-Perfect-Squares%2F</url>
    <content type="text"><![CDATA[Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9. 题意：给出一个数n，判断它最少可以由多少个完全平方数相加而成。 ​ 一开始拿到这道题还在那里把1-16的数字都写出来了，想看出什么规律。结果还是太Naive了，比六合彩更没规律。0-0 ​ 然后想用贪心的想法：每次都从完全平方数里面挑出一个最大的（假设为nums[i]）并且比n小的，接着再从完全平方数里面挑出最大的并且比n-nums[i]的，…，依次递推。 ​ 但是很快就知道贪心的不行，看样例给的12就知道了，12 = 4+4+4 才是最优，按照贪心应该是12=9+1+1+1，得由四个数才相加才能等于12。 ​ 看了下Discuss才发现还是dp的问题，看来对dp的理解还是不够深刻，想了那么久都没看出可以用dp来解决这道题。 ​ 理解了之后，发现这道题跟刚刚做的最长上升子序列300. Longest Increasing Subsequence 其实异曲同工啊！ ​ 定义dp[i]为:=i 由完全平方数组合起来和等于i的最小个数。 那么i可以由之前的状态怎么推导出来呢？ ​ 不就是对于所有满足条件的j，dp[i] = dp[i-jj] + 1; 其中 1&lt;= j\j &lt; i; ​ 然后维护dp[i]最小值dp[i] = min(dp[i], dp[i - j * j] + 1)就好了吗？0-0 ​ 以样例给的12和13为例： ​ Code: 12345678910111213141516171819202122//// Created by chaopengz on 2017/12/3.//#include "head.h"class Solution &#123;public: int numSquares(int n) &#123; vector&lt;int&gt; dp(n + 1, INT32_MAX); dp[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j * j &lt;= i; ++j) &#123; dp[i] = min(dp[i], dp[i - j * j] + 1); &#125; &#125; return dp[n]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[300. Longest Increasing Subsequence]]></title>
    <url>%2F2017%2F12%2F02%2F300-Longest-Increasing-Subsequence%2F</url>
    <content type="text"><![CDATA[Given an unsorted array of integers, find the length of longest increasing subsequence. For example,Given [10, 9, 2, 5, 3, 7, 101, 18],The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity. Follow up: Could you improve it to O(n log n) time complexity? 题意：最长上升子序列。 ​ 最长上升子序列，应该是DP里面很经典的问题了，可是一开始想靠自己的想法把它推出来，结果还是有点难度。特别是在定义状态花费了太多时间，因为看到题目提示是O（N^2）的复杂度，所以以为状态会是dp[i][j]这种二维的形式。定势思维了，要改! ​ 后来再想，dp问题的核心在于划分子问题上。想清楚1：能否划分为子问题 ；2：怎么从子问题推导出母问题(状态转移) 才是王道啊！ ​ 所以嘛，令dp[i]为以i为结尾的最长子序列。则dp[i]可以由前面怎么推出来呢？ ​ 对于所有的0&lt;=j\ nums[j]，那么可得dp[i] = dp[j] + 1;但是我们要求最长上升子序列，所以只需要维护所有j里面算出来dp[i]是最大的那个：dp[i] = max(dp[i], dp[j] + 1);** 1234567891011121314151617181920212223class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if(!len) return 0; int ans = 1; vector&lt;int&gt; dp(len, 1); for (int i = 1; i &lt; len; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (nums[i] &gt; nums[j]) &#123; dp[i] = max(dp[i], dp[j] + 1); &#125; &#125; ans = max(ans, dp[i]); &#125; return ans; &#125;&#125;; ​ 参考了下Discuss大神的O(nLogN)的做法，不是特别能理解，所以在先做个摘录。 tails is an array storing the smallest tail of all increasing subsequences with length i+1 in tails[i].For example, say we have nums = [4,5,6,3], then all the available increasing subsequences are: 12345&gt; len = 1 : [4], [5], [6], [3] =&gt; tails[0] = 3&gt; len = 2 : [4, 5], [5, 6] =&gt; tails[1] = 5&gt; len = 3 : [4, 5, 6] =&gt; tails[2] = 6&gt;&gt; &gt; We can easily prove that tails is a increasing array. Therefore it is possible to do a binary search in tails array to find the one needs update. Each time we only do one of the two: 1234&gt; (1) if x is larger than all tails, append it, increase the size by 1&gt; (2) if tails[i-1] &lt; x &lt;= tails[i], update tails[i]&gt;&gt; &gt; Doing so will maintain the tails invariant. The the final answer is just the size. 参考大神的想法自己写出O(nLogN)的c++代码： 12345678910111213141516171819202122232425262728//// Created by chaopengz on 2017/12/2.//#include "head.h"class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt; &amp;nums) &#123; int len = nums.size(); if (!len) return 0; vector&lt;int&gt; dp; vector&lt;int&gt;::iterator low; for (auto i:nums) &#123; low = lower_bound(dp.begin(),dp.end(),i); if(low == dp.end()) dp.push_back(i); else dp[low-dp.begin()] = i; &#125; int ans = dp.size(); return ans; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[416. Partition Equal Subset Sum]]></title>
    <url>%2F2017%2F12%2F02%2F416-Partition-Equal-Subset-Sum%2F</url>
    <content type="text"><![CDATA[Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note: Each of the array element will not exceed 100. The array size will not exceed 200. Example 1: 1234567&gt; Input: [1, 5, 11, 5]&gt;&gt; Output: true&gt;&gt; Explanation: The array can be partitioned as [1, 5, 5] and [11].&gt;&gt; &gt; Example 2: 123456&gt; Input: [1, 2, 3, 5]&gt;&gt; Output: false&gt;&gt; Explanation: The array cannot be partitioned into equal sum subsets.&gt; ​ 题意：给出一个数列，判断是否可以把这个数列切割成两部分，使得每部分的和相等。 ​ 假设数列的和为sum，很容易可以把问题转化为：数列中是否存在子数列，使得和为sum/2。 ​ 一开我的想法还是比较单纯的，就是使用递归（但是不需要回溯，因为不需要记录具体怎么分）。从数列的第i个数开始寻找是否有和为target的子数列，可以分解为从数列的第i+1个数开始寻找是否有和为target或（||）者和为target-nums[i]的子数列。 123456789101112131415161718192021222324252627class Solution &#123;public: bool canPartition(vector&lt;int&gt; &amp;nums) &#123; int sum = 0; for (auto i:nums) sum += i; sort(nums.begin(), nums.end()); if (sum % 2) return false; int target = sum / 2; return findTargetSum(nums,0,target); &#125; bool findTargetSum(vector&lt;int&gt; nums, int i, int target) &#123; if (!target) return true; if (target &lt; 0 || i == nums.size()) return false; return findTargetSum(nums, i + 1, target) || findTargetSum(nums, i + 1, target - nums[i]); &#125;&#125;; ​ 能够样例但是提交上去超时了。理由很简单啊，数组长度最大有200个，那么意味这复杂度为O(2^200)啊，指数增长，不爆炸才怪呢。 ​ 其实对于数列中个每个数来说，在组成和为target的问题上，都有两种选择选择：选 or 不选。跟什么问题很像？对，就是耳熟能详的01背包！所以接下来就是如何思考1：定义状态以及2：推导状态转移了。 ​ 1：定义状态：dp[i][j]：数列的前i个数是否存在和为j的子数列。 ​ 2：状态转移：dp[i][j] = dp[i-1][j] || dp[i-1][ j-nums[i] ]。 ​ 因为i的取值范围是0到200，而题目说数列的每个数不会超过100，所以j的最大取值就是200*100 = 20000，整体的复杂度为：20000*200 = 4000000。 ​ 本来想到这就可以很容易地写出下面的状态转移代码： 1234567for(int i = 1;i &lt; len, i++)&#123; for(int j = 0 ; j &lt;= len*100; j++) &#123; dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]] &#125;&#125; ​ 这样就ok了吗？显然不行，为什么呢？ ​ 因为j-nums[i]可能会出现负数啊（最简单就是j=0的时候），这样dp索引负数就出错了。 ​ 想到这儿的时候，突然觉得和之前做的494-Target-Sum很相似，同样是01背包问题，也同样会出现索引为负数的情况。 ​ 所以我们可以这么转化，既然第i行的数据由第i-1来决定，是否也意味着：第i行的数据会影响到第i+1行？所以就可以上述的状态转移代码改成： 1234567891011for (int i = 0; i &lt; len - 1; ++i) &#123; for (int j = 0; j &lt;= len * 100; ++j) &#123; if (dp[i][j]) &#123; dp[i + 1][j] = true; dp[i + 1][j + nums[i + 1]] = true; &#125; &#125; &#125; ​ 这样就不会出现上述哪个存在索引为负数的情况了！ Code: 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: bool canPartition(vector&lt;int&gt; &amp;nums) &#123; int sum = 0; int len = nums.size(); for (auto i:nums) sum += i; sort(nums.begin(), nums.end()); if (sum % 2) return false; vector&lt;vector&lt;bool&gt;&gt; dp(len, vector&lt;bool&gt;(len * 100 + 1, false)); dp[0][0] = true; dp[0][nums[0]] = true; for (int i = 0; i &lt; len - 1; ++i) &#123; for (int j = 0; j &lt;= len * 100; ++j) &#123; if (dp[i][j]) &#123; dp[i + 1][j] = true; dp[i + 1][j + nums[i + 1]] = true; &#125; &#125; &#125; int target = sum / 2; return dp[len - 1][target]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[101. Symmetric Tree]]></title>
    <url>%2F2017%2F12%2F01%2F101-Symmetric-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1234567&gt; 1&gt; / \&gt; 2 2&gt; / \ / \&gt; 3 4 4 3&gt;&gt; &gt; But the following [1,2,2,null,3,null,3] is not: 1234567&gt; 1&gt; / \&gt; 2 2&gt; \ \&gt; 3 3&gt;&gt; &gt; Note:Bonus points if you could solve it both recursively and iteratively. 题意：判断一棵树是否镜面对称。 ​ 因为前不久刚做了个二叉树的小结 ，知道了做二叉树大概的套路： 判断空值 处理节点 递归处理左子树和右子树（其实就是分解成子问题） ​ 然而，竟然思索了一会没有想到递归的解法。因为我想分解成左子树和右子树也分别镜面对称，但是结合样例就知道看起来不对啊。 ​ 但是发现非递归的解法，就是层序遍历，然后每一层都是回文的。但是有个细节需要注意就是空值，所有的空的地方我都人为地用-1来替代了。 ​ Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode *root) &#123; if (!root) return true; queue&lt;TreeNode *&gt; qTree; vector&lt;int&gt; v; qTree.push(root); int len; TreeNode *node; int count = 0;//计算-1，即空值的个数 while (count &lt; qTree.size()) &#123; v.clear(); count = 0; len = qTree.size(); for (int i = 0; i &lt; len; ++i) &#123; node = qTree.front(); qTree.pop(); if (node) &#123; v.push_back(node-&gt;val); qTree.push(node-&gt;left); qTree.push(node-&gt;right); if (!node-&gt;left) count += 1; if (!node-&gt;right) count += 1; &#125; else &#123; v.push_back(-1); qTree.push(nullptr); qTree.push(nullptr); count += 2; &#125; &#125; if (isSymmetricVector(v)) continue; else return false; &#125; return true; &#125; bool isSymmetricVector(vector&lt;int&gt; v) &#123; int len = v.size(); for (int i = 0; i &lt; len / 2; ++i) &#123; if (v[i] != v[len - i - 1]) return false; &#125; return true; &#125;&#125;; ​ 今早起来看了下Discussion，发现是自己的子问题没有分解好。这里需要借助一个辅助函数，用来判断两棵树是否相同。这样镜面对称就可以这么分解子问题了： ​ 1：两个根值要相同 ​ 2：左树的左子树要和右树的右子树相同 并且 左树的右子树要和右树的左子树相同 Code: 123456789101112131415161718192021222324class Solution &#123;public: bool isSymmetric(TreeNode *root) &#123; if (!root) return true; return isSymmetric(root-&gt;left, root-&gt;right); &#125; bool isSymmetric(TreeNode *left, TreeNode *right) &#123; if (!left &amp;&amp; !right) return true; else if (left &amp;&amp; right) &#123; if (left-&gt;val != right-&gt;val) return false; return isSymmetric(left-&gt;left, right-&gt;right) &amp;&amp; isSymmetric(left-&gt;right, right-&gt;left); &#125; else &#123; return false; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[53. Maximum Subarray]]></title>
    <url>%2F2017%2F12%2F01%2F53-Maximum-Subarray%2F</url>
    <content type="text"><![CDATA[Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. 题意：找出和最大的连续子序列。 ​ 这道题其实一个月前开始就开始写了 ，但是错了好多次。之前想的是，不就是求Sum[i…j]最大嘛，那直接遍历所有i和j的所有可能取值就行了。复杂度为O（n^2），理所当然的超时了。 123456789101112131415161718class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int sum; int n = nums.size(); int ans = -2147483647; for (int i = 0; i &lt; n ; ++i) &#123; sum = 0; for (int j = i ; j &lt; n; ++j) &#123; sum += nums[j]; ans = max(sum, ans); &#125; &#125; return ans; &#125;&#125;; ​ 刚好这两天做了一道十分相似的题目：560. Subarray Sum Equals K ，了解到了前缀和这种神奇的东西。所以一个月后再来看这道之前一直没解决的问题，还是觉得当时实在是太naive了。这不也就利用前缀和就可以在O（N）的复杂度内解决的么？ ​ 假设sum以是j为结尾的前缀和，那么只需要减去j以前的最小的前缀和，那么就可以得到以j为结尾的和最大连续子序列。遍历每个j，然后维护最大值就ok啦~~注意：preSum[-1] = 0。 1234567891011121314151617181920212223242526class Solution &#123;public: int maxSubArray(vector&lt;int&gt; &amp;nums) &#123; int len = nums.size(); if (!len) return 0; if (len == 1) return nums[0]; else &#123; int sum = nums[0]; int minPreSum = min(0, nums[0]); int ans = nums[0]; for (int i = 1; i &lt; nums.size(); i++) &#123; sum += nums[i]; ans = max(ans, sum - minPreSum);//维护子序列和最大值 minPreSum = min(sum, minPreSum);//维护j之前的最小子序列和 &#125; return ans; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[39. Combination Sum & 40. Combination Sum II]]></title>
    <url>%2F2017%2F11%2F30%2F39-Combination-Sum-40-Combination-Sum-II%2F</url>
    <content type="text"><![CDATA[39： Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is: 12345&gt; [&gt; [7],&gt; [2, 2, 3]&gt; ]&gt; ​ 题意：从给出的数列选出若干元素，使它们之和为target，并且取的时候每个元素可以任取多次，求问有多少种组合。 ​ 因为看到这个每个元素可以取多次，所以还以为是完全背包，但回顾了下背包问题后又发现。背包求的是价值最大，然而这里求的是和恰好为target. ​ 百思不得其解看了下discussion，解题思路原来是递归和回溯。确实不就是不断地试，试到失败就回溯吗？ ​ 针对样例，先把2拿出来，然后重新继续在[2,2,3]里找和5（7-2）的可能。即在i位置递归的时候仍然是从数组的第i位置开始去解决子问题。 Code: 12345678910111213141516171819202122232425262728293031323334//// Created by chaopengz on 2017/11/30.//#include "head.h"class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt; &amp;candidates, int target) &#123; sort(candidates.begin(), candidates.end()); vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; v; combinationSum(candidates, 0, ans, v, target); return ans; &#125; void combinationSum(vector&lt;int&gt; &amp;candidates, int begin, vector&lt;vector&lt;int&gt;&gt; &amp;ans, vector&lt;int&gt; &amp;v, int target) &#123; if (!target) &#123; ans.push_back(v); return; &#125; for (int i = begin; i &lt; candidates.size() &amp;&amp; target &gt;= candidates[i]; ++i) &#123; v.push_back(candidates[i]); combinationSum(candidates, i, ans, v, target - candidates[i]); v.pop_back(); &#125; &#125;&#125;; 40: Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,A solution set is: 12345678&gt; [&gt; [1, 7],&gt; [1, 2, 5],&gt; [2, 6],&gt; [1, 1, 6]&gt; ]&gt;&gt; ​ 第40题和第39题很类似，只不过把约束条件改成了每个元素最多只能取一次。本来应该是比较简单的，就是每次在i位置递归的时候从数组的第i+1开始解决子问题。 ​ 但是呢，有一个比较棘手的问题，就是数组里面如果有元素是重复的，那么等会按照之前的递归回溯就会有重复。 ​ 针对样例，排完序后的数组为[1,1,2,5,6,7,10]。 ​ 那么按照在i位置递归的时候从数组的第i+1开始解决子问题的思路，等会就有两个[1,2,5]出来。为什么呢？ 因为1有两个啊，第一个[1,2,5]里的1是数组的第一个1，第二个[1,2,5]里的1是数组的第二个1. ​ 那咋办呢？ ​ 其实也不难解决，想想对于相同的元素，假设该元素的出现了n次。 ​ 还是以样例为例子，有两个1。那么我可以取1个1，或者两个2。 取一个1，那么就是在[2,5,6,7,10]里找8-1*1 取两个1，那么就是在[2,5,6,7,10]里找8-1*2 这样就可以避免重复答案啦~~~ Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//// Created by chaopengz on 2017/11/30.//#include "head.h"class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt; &amp;candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; v; sort(candidates.begin(), candidates.end()); for (auto i:candidates) m[i]++; combinationSum2(ans, v, target, candidates, 0); return ans; &#125; void combinationSum2(vector&lt;vector&lt;int&gt;&gt; &amp;ans, vector&lt;int&gt; &amp;v, int target, vector&lt;int&gt; candidates, int begin) &#123; if (!target) &#123; ans.push_back(v); return; &#125; for (int i = begin; i &lt; candidates.size() &amp;&amp; target &gt;= candidates[i]; i += m[candidates[i]]) &#123; for (int k = 1; k &lt;= m[candidates[i]]; ++k) &#123; for (int j = 1; j &lt;= k; ++j) &#123; v.push_back(candidates[i]); &#125; //递归 combinationSum2(ans, v, target - candidates[i] * k, candidates, i + m[candidates[i]]); //回溯 for (int j = 1; j &lt;= k; ++j) &#123; v.pop_back(); &#125; &#125; &#125; &#125; map&lt;int, int&gt; m;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[560. Subarray Sum Equals K]]></title>
    <url>%2F2017%2F11%2F30%2F560-Subarray-Sum-Equals-K%2F</url>
    <content type="text"><![CDATA[Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example 1: 1234&gt; Input:nums = [1,1,1], k = 2&gt; Output: 2&gt;&gt; &gt; Note: The length of the array is in range [1, 20,000]. The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7]. ​ 题意：给出一个数列，找出其连续的子序列之和为k的可能种数。 ​ 其实就是找出a[i]到a[j]之和为k有多少种可能，我想到就是纯粹的暴力做法，遍历i和j（i&lt;=j&lt;=nums.size()）的所有可能性求解。 12345678910111213141516171819202122class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; if(!nums.size()) return 0; int len = nums.size(); int ans = 0; int sum; for (int i = 1; i &lt;= len; ++i) &#123; sum = 0; for (int j = i; j &lt;= len; ++j) &#123; sum += nums[j - 1]; if(sum==k) ans++; &#125; &#125; return ans; &#125;&#125;; ​ 复杂度为O（N^2）一开始以为会超时，没想到竟然能通过。但是肯定不能满足于O（N^2）的做法，所以看了下Discussion发现大佬还是有O（N）的做法的。 ​ 因为这里要求的是sum[i…j]，这里是连续的，所以不需要每次都遍历逐项相加。利用前缀和就可以简便好多。 ​ sum[i…j] = preSum[j] - preSum[i-1] ​ 所以我们只需遍历一遍数组，假设遍历到了a[i]，那么此时sum就是preSum[i]，那么就只需要找一找在i之前有没有哪个前缀和为为sum-k（FindNum）就可以咯~ ​ 123456789101112131415161718class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; map&lt;int, int&gt; preSum;//preSum&lt;a,b&gt;:前缀和为a的有b种可能 int ans = 0; int sum = 0; int findNum; preSum[0]++; for (int i = 0; i &lt; nums.size(); ++i) &#123; sum += nums[i]; findNum = sum - k; ans += preSum[findNum]; preSum[sum]++; &#125; return ans; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[309. Best Time to Buy and Sell Stock with Cooldown]]></title>
    <url>%2F2017%2F11%2F28%2F309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown%2F</url>
    <content type="text"><![CDATA[Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day) Example: 12345&gt; prices = [1, 2, 3, 0, 2]&gt; maxProfit = 3&gt; transactions = [buy, sell, cooldown, buy, sell]&gt;&gt; &gt; Credits:Special thanks to @dietpepsi for adding this problem and creating all test cases 题意：给出股票的每天的价格，求买卖股票的最大收益。有两个约束条件： 1、 卖股票之前必要有股票在手. 2、卖完股票的时候必须隔一天才能再买（cooldown）。 Code: 1234567891011121314151617181920212223242526272829//// Created by cpz on 2017/11/28.//#include "head.h"class Solution &#123;public: int maxProfit(vector&lt;int&gt; &amp;prices) &#123; int len = prices.size(); if (len &lt;= 1) return 0; vector&lt;int&gt; s0; vector&lt;int&gt; s1; vector&lt;int&gt; s2; s0.push_back(0); s1.push_back(-prices[0]); s2.push_back(INT_MIN); for (int i = 1; i &lt; len; ++i) &#123; s0.push_back(max(s0[i - 1], s2[i - 1])); s1.push_back(max(s0[i - 1] - prices[i], s1[i - 1])); s2.push_back(s1[i - 1] + prices[i]); &#125; return max(s0[len - 1], s2[len - 1]); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[96. Unique Binary Search Trees]]></title>
    <url>%2F2017%2F11%2F23%2F96-Unique-Binary-Search-Trees%2F</url>
    <content type="text"><![CDATA[Given n, how many structurally unique BST’s (binary search trees) that store values 1…n? For example,Given n = 3, there are a total of 5 unique BST’s. 123456&gt; 1 3 3 2 1&gt; \ / / / \ \&gt; 3 2 1 1 3 2&gt; / / \ \&gt; 2 1 2 3&gt; &gt; 题意：给一个数字n，计算把[1,n]组成一颗二叉树有多少种方式。 Code: 123456789101112131415161718192021222324252627//// Created by cpz on 2017/11/23.//#include "head.h"class Solution &#123;public: int numTrees(int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(n + 2, vector&lt;int&gt;(n + 2, 1)); for (int len = 1; len &lt; n; ++len) &#123; for (int start = 1; start + len&lt;= n ; ++start) &#123; int end = start + len ; int sum = 0; for (int k = start; k &lt;= end ; ++k) &#123; sum+=dp[start][k-1]*dp[k+1][end]; &#125; dp[start][end] = sum; &#125; &#125; return dp[1][n]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[394. Decode String]]></title>
    <url>%2F2017%2F11%2F23%2F394-Decode-String%2F</url>
    <content type="text"><![CDATA[Given an encoded string, return it’s decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4]. Examples: 1234&gt; s = &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.&gt; s = &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.&gt; s = &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;.&gt; 题意：按照加密规则解密字符串。 ​ 初看这道题时就感觉跟本科学数据结构时的表达式运算差不多，因为有嵌套关系并且是里层的先解密，即满足后进先出的特点，所以就需要利用到栈。但是在实验室思绪比较混乱，想了两小时愣是没做出来，就是在消耗时间，不够专注。 ​ 晚上回宿舍后静下心来来想不到半小时就把思路和代码都理清了！可见，宁静致远！ ​ 其实最主要就是维护好两个栈，一个数字的nums和需要被解密的字符串chars。 ​ 每次读进来一个字符c=s[i]，这时c无非就以下几种情况，分别处理。 “[“：把[前面的数字入nums栈,然后加个空字符“”入栈，代表以后的字符串是需要被解密的（即需要被解密的字符串又多了一个了）。 “]”：从nums取栈头n并退栈，从chars取栈str头并退栈，计算出str解密后的endcode，将j解密后encode接到chars栈头字符串的后面，等待一下次解密。 数字：加到数字字符串strNum (数字并不是个位数，有可能多位，如100) 字母：将字母接到chars栈头字符串的后面，等待解密。 当把读进来的字符串s挨个字符都处理完之后，chars栈头就是最后答案了！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//// Created by cpz on 2017/11/22.//#include "head.h"class Solution &#123;public: string decodeString(string s) &#123; stack&lt;string&gt; chars; chars.push(""); stack&lt;int&gt; nums; string c; string encode = ""; string str; int n; string strOfNums = ""; for (int i = 0; i &lt; s.size(); ++i) &#123; c = s[i]; if (c == "[") &#123; n = atoi(strOfNums.c_str()); nums.push(n); strOfNums = ""; chars.push(""); &#125; else if (c == "]") &#123; str = chars.top(); chars.pop(); n = nums.top(); nums.pop(); encode = ""; for (int j = 0; j &lt; n; ++j) &#123; encode += str; &#125; encode = chars.top() + encode; chars.pop(); chars.push(encode); &#125; else if (has_only_digits(c))//num &#123; strOfNums += c; &#125; else//字母 &#123; encode = chars.top(); chars.pop(); encode += c; chars.push(encode); &#125; &#125; return chars.top(); &#125; bool has_only_digits(const string s) &#123; return s.find_first_not_of("0123456789") == string::npos; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUG合集]]></title>
    <url>%2F2017%2F11%2F22%2FBUG%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[不能既使用迭代又同时更新。 Wrong 1234567891011121314vector&lt;vector&lt;int&gt;&gt; ans; for (auto i:nums) &#123; for (auto&amp; row:ans)//使用了ans的迭代 &#123; vector&lt;int&gt; k; for (auto&amp; col:row) &#123; k.push_back(col); &#125; k.push_back(i); ans.push_back(k);//同时又修改了ans，错误！！ &#125; &#125; Right 12345678910111213141516vector&lt;vector&lt;int&gt;&gt; ans; for (auto i:nums) &#123; vector&lt;vector&lt;int&gt;&gt; pre;//要用一个pre来保存上一步的ans pre = ans;//然后对pre迭代，对ans修改，这样就对了~ for (auto&amp; row:pre) &#123; vector&lt;int&gt; k; for (auto&amp; col:row) &#123; k.push_back(col); &#125; k.push_back(i); ans.push_back(k); &#125; &#125; ​]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[312. Burst Balloons]]></title>
    <url>%2F2017%2F11%2F21%2F312-Burst-Balloons%2F</url>
    <content type="text"><![CDATA[Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely. Note:(1) You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them.(2) 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 Example: Given [3, 1, 5, 8] Return 167 123&gt; nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []&gt; coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167&gt; ​ 题意：戳破一个气球(序号为i)就可以得到nums[i-1]nums[i]\nums[i+1]的得分，求问怎么得戳破所有气球然后得分最高。 ​ 一开始看这个题真的是一点思路都没有，别说敲代码实现了，就是自己手动算的都不知道从何而算起。 ​ 没有思路的主要问题是没办法把这个题目划分为子问题，好像觉得在每一步要戳破哪个很难决定。最后看了discuss后恍然大悟，要这么划分自问题的： ​ 要戳破[i,j]区间的气球，那么如果k为最后一个戳破的，那么以d[i][j]表示得分，则 123dp[i][j] = &#123; dp[i][k-1]/*戳破k左边的得分*/+dp[k+1][j]/*戳破k右边的得分*/+nums[i-1]*nums[k]*nums[j+1]/*戳破k的的得分*/&#125; ​ 这样子问题不就划分好了吗~？ ​ 需要计算最大值，那么只要按个遍历[i,j]中的每一个可能值k,然后维护最大值即可。表示如下： 123for k in [i,j]: dp[i][j] = max(dp[i][j], dp[i][k - 1] + dp[k + 1][j] + balloons[i - 1] * balloons[k] * balloons[j + 1]); ​ 虽然到此思路有了，但是一开始提交还是错掉了。主要是对dp二维表的计算顺序搞错了！ 错误的计算顺序： 1234567891011121314151617181920212223242526272829303132333435//// Created by chaopengz on 2017/11/21.//#include "head.h"class Solution &#123;public: int maxCoins(vector&lt;int&gt; &amp;nums) &#123; int len = nums.size(); vector&lt;int&gt; balloons; balloons.push_back(1); for (auto x:nums) balloons.push_back(x); balloons.push_back(1); vector&lt;vector&lt;int&gt;&gt; dp(balloons.size(), vector&lt;int&gt;(balloons.size(), 0)); for (int i = 1; i &lt;= len; ++i) &#123; for (int j = i; j &lt;= len; ++j) &#123;//计算dp[i][j] for (int k = i; k &lt;= j; ++k)//k为[i,j]最后一个戳破的气球 &#123; dp[i][j] = max( dp[i][j], dp[i][k - 1] + dp[k + 1][j] + balloons[i - 1] * balloons[k] * balloons[j + 1] ); &#125; &#125; &#125; return dp[1][len]; &#125;&#125;; ​ 错误主要是因为：跟之前的第i行的结果依赖第i-1行的思想不一样，这次的是i+1行对i行也有影响，所以对角线的要先算，比如在计算dp[1][2]时，当k=1时 1dp[1][2] = max(dp[1][2],dp[1][0]+dp[2][2]+balloons[0]*ballons[1]*ballons[3])//这时要dp[1][2]就得先有dp[2][2] ​ 正确的AC代码： 1234567891011121314151617181920212223242526272829303132//// Created by chaopengz on 2017/11/21.//#include "head.h"class Solution &#123;public: int maxCoins(vector&lt;int&gt; &amp;nums) &#123; int len = nums.size(); vector&lt;int&gt; balloons; balloons.push_back(1); for (auto x:nums) balloons.push_back(x); balloons.push_back(1); vector&lt;vector&lt;int&gt;&gt; dp(balloons.size(), vector&lt;int&gt;(balloons.size(), 0)); for (int step = 0; step &lt; len; ++step) &#123; for (int i = 0; i &lt;= len - step; ++i) &#123; int j = i + step; for (int k = i; k &lt;= j; ++k)//k为[i,j]最后一个戳破的气球 &#123; dp[i][j] = max( dp[i][j], dp[i][k - 1] + dp[k + 1][j] + balloons[i - 1] * balloons[k] * balloons[j + 1] ); &#125; &#125; &#125; return dp[1][len]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[494. Target Sum]]></title>
    <url>%2F2017%2F11%2F17%2F494-Target-Sum%2F</url>
    <content type="text"><![CDATA[You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol. Find out how many ways to assign symbols to make sum of integers equal to target S. Example 1: 12345678910111213&gt; Input: nums is [1, 1, 1, 1, 1], S is 3. &gt; Output: 5&gt; Explanation: &gt;&gt; -1+1+1+1+1 = 3&gt; +1-1+1+1+1 = 3&gt; +1+1-1+1+1 = 3&gt; +1+1+1-1+1 = 3&gt; +1+1+1+1-1 = 3&gt;&gt; There are 5 ways to assign symbols to make the sum of nums be target 3.&gt;&gt; &gt; Note: The length of the given array is positive and will not exceed 20. The sum of elements in the given array will not exceed 1000. Your output answer is guaranteed to be fitted in a 32-bit integer. ​ 题意：给出一个数组，每个数前面可以添加正负号的其中一种，凑成一个表达式，求表达式之和刚好等于target有多少种可能性。 ​ 一开始采用的是递归的写法，类似于二叉树的打印路径的思想。当走到最后一个数字是，判断此时的和是否刚好为target，如果是，则ans++。 ​ 这种思想还犯了一个致命的错误：全局变量保存在堆里面，没有被销毁，临时变量保存在栈里面，会被销毁。 1234567891011121314151617181920212223242526272829303132333435363738//// Created by chaopengz on 2017/11/16.//#include "head.h"class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt; &amp;nums, int S) &#123; findSumRecur(nums, 0, S); return ans; &#125; void findSumRecur(vector&lt;int&gt; nums, int i, int target) &#123; if (i == nums.size()) &#123; if (target == 0) ans++; return; &#125; else &#123; int subSum1 = target - nums[i]; int subSum2 = target + nums[i]; cout &lt;&lt; subSum1 &lt;&lt; " " &lt;&lt; subSum2 &lt;&lt; endl; j = ++i;//致命错误，此时j是全局变量，不会被销毁 cout &lt;&lt; "j=" &lt;&lt; j &lt;&lt; endl; findSumRecur(nums, j, subSum1); findSumRecur(nums, j, subSum2); &#125; &#125; int ans = 0; int j;&#125;; 递归的正确写法但是超时了，显然递归的时间开销太大了。得改用其他思路。 123456789101112131415161718192021222324252627282930313233343536//// Created by chaopengz on 2017/11/16.//#include "head.h"class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt; &amp;nums, int S) &#123; findSumRecur(nums, 0, S); return ans; &#125; void findSumRecur(vector&lt;int&gt; nums, int i, int target) &#123; if (i == nums.size()) &#123; if (target == 0) ans++; return; &#125; else &#123; int subSum1 = target - nums[i]; int subSum2 = target + nums[i]; int j = ++i;//正确地写法，会在每一个递归栈里有一个临时变量 findSumRecur(nums, j, subSum1); findSumRecur(nums, j, subSum2); &#125; &#125; int ans = 0;&#125;; ​ 后来仔细一想，这个问题其实就是背包的变种，在背包问题中，状态转移的条件是：选或不选，在这个问题则是，加还是减。 定义状态：dp[i][j]: 数组前i个数字组成的表达式之和为j的可能性种数。 这样状态转移方程为： dp[i][j] = dp[i-1][ j+nums[i] ] + dp[i-1][ j-nums[i] ] 虽然思路是对的，但是实现起来还是有很多需要注意的细节，比如刚实现dp在本地是对的，但是提交到远程就错了。 123456789101112131415161718192021222324252627282930313233//// Created by chaopengz on 2017/11/16.//#include "head.h"class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt; &amp;nums, int S) &#123; int N = 20000; vector&lt;vector&lt;int&gt;&gt; dp; dp.resize(20, vector&lt;int&gt;(N)); for (int j = -N/2; j &lt; N/2; ++j) &#123; if (!nums[0])//第一个为0,则dp[0][0]有两个解，正0和负0 dp[0][0] = 2; else if (j == nums[0] || j == -nums[0]) dp[0][j] = 1; else dp[0][j] = 0; &#125; for (int i = 1; i &lt; nums.size(); ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; dp[i][j] = dp[i - 1][j - nums[i]] + dp[i - 1][j + nums[i]]; &#125; &#125; return dp[nums.size() - 1][S]; &#125;&#125;; ​ 错的主要原因就是dp的第二维：j - nums[i]，有可能是小于0的数。这样递推起来肯定就有问题了。所以咋办呢？ ​ 其实上述代码的主要思路是这样的：第i行第j列是由第i-1行的两个具体列（j-nums[i],j+nums[i]）来决定的，这样就在找j-nums[i]列时可能就找不到了。 ​ 不妨换个角度思考，既然第i行由第i-1行来决定，那么是不是也意味着，第i行可以决定第i+1行的数据呢？也就是说，对第i行中每个不为0的数，都会被加到下一行(i+1)的j+nums[i+1] 和j-nums[i+1]这两列中去。因为题意说sum之和不会超过1000，并且我们把列数都进行了平移（第二维度的坐标从-sum -&gt; +sum），所以就能保证j-nums[i+1]一定不会小于0啦~ ​ 具体可以看图示： 最后终于AC了的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//// Created by chaopengz on 2017/11/16.//#include "head.h"class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt; &amp;nums, int S) &#123; int sum = 0; for(auto i:nums) sum += i; int cols = 2*sum+1; if (S &gt; sum || S&lt; -sum) return 0; int dp[20][4005]; memset(dp, 0, sizeof(dp)); for (int j = 0; j &lt; cols; ++j) &#123; if (!nums[0])//第一个为0,则dp[0][sum]有两个解，正0和负0 dp[0][sum] = 2; else if (j == nums[0] + sum || j == -nums[0] + sum) dp[0][j] = 1; else dp[0][j] = 0; &#125; for (int i = 0; i &lt; nums.size()-1; ++i) &#123; for (int j = 0; j &lt; cols; ++j) &#123; //dp[i][j] = dp[i - 1][j - nums[i]] + dp[i - 1][j + nums[i]]; if(dp[i][j]) &#123; dp[i+1][j-nums[i+1]] += dp[i][j]; dp[i+1][j+nums[i+1]] += dp[i][j]; &#125; &#125; &#125; return dp[nums.size() - 1][sum+S]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[337. House Robber III]]></title>
    <url>%2F2017%2F11%2F16%2F337-House-Robber-III%2F</url>
    <content type="text"><![CDATA[The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Example 1: 1234567&gt; 3&gt; / \&gt; 2 3&gt; \ \ &gt; 3 1&gt;&gt; &gt; Maximum amount of money the thief can rob = 3+ 3 + 1 = 7 Example 2: 1234567&gt; 3&gt; / \&gt; 4 5&gt; / \ \ &gt; 1 3 1&gt;&gt; &gt; Maximum amount of money the thief can rob = 4 + 5 = 9 Credits:Special thanks to @dietpepsi for adding this problem and creating all test cases. ​ 题意：一颗二叉树中，不同在一条边的节点中，和最大的是多少？ ​ 因为刚做二叉树的总结，知道了二叉树大概的处理思路：空值—&gt;根节点—&gt;左右子树。所以这道题最主要也还是大体按照这个思路进行求解。 ​ 对于每一个根节点，无非就两种选择：选或者不选。 根节点选了，那么只能根节点的左右孩子都不能再选了，只能选出以孙子为根节点时（子问题）和的最大值之和 根节点如果没选，那么此时和最大就是分别以左右孩子为根节点时（子问题）的和的最大值之和。 ​ 一开始出错的地方在于：因为越了一层进行处理，忘了要对二级指针进行是否为空指针进行判断。 具体代码： 1234567891011121314151617181920212223242526272829//// Created by chaopengz on 2017/11/15.//#include "head.h"class Solution &#123;public: int rob(TreeNode *root) &#123; if (!root) return 0; if (!root-&gt;left &amp;&amp; !root-&gt;right)//leaf node return root-&gt;val; if (root-&gt;left &amp;&amp; root-&gt;right) return max(rob(root-&gt;left) + rob(root-&gt;right), root-&gt;val + rob(root-&gt;left-&gt;left) + rob(root-&gt;left-&gt;right) + rob(root-&gt;right-&gt;left) + rob(root-&gt;right-&gt;right)); if (root-&gt;left)//越了一层，需要用到二级指针，所以进行非空判断 return max(rob(root-&gt;left) + rob(root-&gt;right), root-&gt;val + rob(root-&gt;left-&gt;left) + rob(root-&gt;left-&gt;right)); else return max(rob(root-&gt;left) + rob(root-&gt;right), root-&gt;val + rob(root-&gt;right-&gt;left) + rob(root-&gt;right-&gt;right)); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[543. Diameter of Binary Tree]]></title>
    <url>%2F2017%2F11%2F15%2F543-Diameter-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Example:Given a binary tree 1234567&gt; 1&gt; / \&gt; 2 3&gt; / \ &gt; 4 5 &gt;&gt; &gt; Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. Note: The length of path between two nodes is represented by the number of edges between them. 题意：叶子节点的最长距离（可不经过根节点）。 ​ 做完二叉树的总结竟然经过自己独立并且一遍AC了！太开心了！果然老外的教程还是比较靠谱的，都怪自己的英语水平还达不到流畅地阅读，继续加油~ ​ 做的思路是这样子的，以root为根节点，计算root左子树根节点(root-&gt;left)到叶子节点的最长距离(由countPath辅助完成)，再加上root右子树根节点(root-&gt;right)到右子树叶子节点的最长距离，这两个距离相加后再加上1(root本身)之后就是以root为根节点的叶子节点间的最长距离。 ​ 然后遍历整棵树的所有节点，用ans为来维护最大值。遍历完后ans就是答案了。 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041//// Created by chaopengz on 2017/11/7.//#include "head.h"struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;&#125;;class Solution &#123;public: int diameterOfBinaryTree(TreeNode *root) &#123; if (!root) return 0; ans = max(countPath(root-&gt;left)+countPath(root-&gt;right)+1,ans); diameterOfBinaryTree(root-&gt;left); diameterOfBinaryTree(root-&gt;right); return ans-1; &#125; int countPath(TreeNode *root)//count root to leaft &#123; if (!root) return 0; else return max(countPath(root-&gt;left), countPath(root-&gt;right)) + 1; &#125; int ans = 0;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树小结]]></title>
    <url>%2F2017%2F11%2F14%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[​ 本科在学习数据结构时学起来就一直很吃力，特别是对于树和图的掌握不是特别牢固。在刷LeetCode关于二叉树的额题目基本束手无力。所以就趁机把二叉树的知识进行回顾，并且总结。找的是斯坦福大学的一位教授写得笔记，通俗易懂，也将几个题目事先按照自己的思路先写一写，再与参考答案进行对照。具体见最后附录。 二叉树​ 每颗二叉树都是由若干个节点组成的，每个节点又是一个结构体，包含左指针，右指针，以及节点的值。其中左、右指针递归地指向一颗新的子树。 定义如下： 123456struct TreeNode&#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x):val(x),left(nullptr),right(nullptr)&#123;&#125;;//构造新节点&#125; 排序二叉树 （BST）​ 排序二叉树除了满足上述二叉树的定义之外，还需要再附加一个约束条件：左子树的值&lt;=根节点&lt;=右子树的值。排序二叉树主要可以大大地降低搜索时间，从O(n)降到O(logn). 思考策略​ 当处理二叉树时，主要集中精力思考两件事情： 弄清节点的结构以及如何处理 如何进行递归解决和遍历整棵树 遵循以下三个思维步骤： 考虑空值（一定要先考虑值为空的处理方法，因为这也是一般递归结束的出口） 处理节点(node) 递归处理左右子树(left,right)要改掉if(非空)的写法，空值都是递归函数里进行处理了，没必要再多此一举 （2，3有时会对调） 简而言之三部曲：①：判空 ；②： 看当前；③：看子树 常见问题 查找（LookUp）12345678910111213141516171819int lookup(TreeNode *root, int target)&#123; //1.BaseCase empty,处理空值 if (!root) return false; else &#123; //2.处理节点值，如果节点值刚好是要查找的 if (target == root-&gt;val) return true; //3.如果不是，那么递归处理子树 else&#123; if(target&lt;root-&gt;val) return lookup(root-&gt;left,target); else return lookup(root-&gt;right,target); &#125; &#125;&#125; ​ 插入（insert）​ 跟查找相比，插入操作需要修改原来的树结构，也就是需要修改指针值。这里采用一种函数调用的方法解决，而不采用c++的引用。 1root = change(root) ​ 所以插入操作需要有一个辅助函数（helper function）来负责创建一个节点，并且返回该节点的指针，其实就是上述二叉树定义代码中的TreeNode(int x)所实现的功能。 1234567891011121314151617TreeNode *insert(TreeNode *root, int data)&#123; //1. 树为空，直接创建并返回这个节点 if (!root) return new TreeNode(data); //2. 处理子树 else &#123; if (data &lt;= root-&gt;val) root-&gt;left = insert(root-&gt;left, data); else root-&gt;right = insert(root-&gt;right, data); //3.处理当前节点 return root; &#125;&#125; 3.建树（Build123）1234567TreeNode *build123()&#123; TreeNode *root = new TreeNode(2); root-&gt;left = new TreeNode(1); root-&gt;right = new TreeNode(3); return root;&#125; 节点数（Size） 123456789int size(TreeNode *root)&#123; if (!root) return 0; else &#123; return size(root-&gt;left) + size(root-&gt;right) + 1; &#125;&#125; 最深深度（maxDepth） 12345678int maxDepth(TreeNode *root)&#123; if (!root) return 0; else return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1;&#125; 最小值（minValue） 1234567int minValue(TreeNode *root)&#123; TreeNode *node = root; while (node-&gt;left) node = root-&gt;left; return node-&gt;val;&#125; 递增打印（printTree） 12345678void printTree(TreeNode *root)&#123; if (!root) return; printTree(root-&gt;left); cout &lt;&lt; root-&gt;val; printTree(root-&gt;right);&#125; 自底向上打印 12345678void printPostorder(TreeNode *root)&#123; if (!root) return; printPostorder(root-&gt;left); printPostorder(root-&gt;right); cout &lt;&lt; root-&gt;val;&#125; 路径之值（hasPathSum） 12345678int hasPathSum(TreeNode *root, int sum)&#123; if (!root) return sum == 0; else return hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val);&#125; 打印所有路径（printPath） 123456789101112131415161718192021222324252627//8.pathvoid printPathRecur(TreeNode *root, vector&lt;int&gt; v)&#123; if (!root) return; //如果是叶子节点，加入vector后输出数组 if ((!root-&gt;left) &amp;&amp; (!root-&gt;right)) &#123; v.push_back(root-&gt;val); for (auto i:v) cout &lt;&lt; i &lt;&lt; " "; cout &lt;&lt; endl; &#125; //如果非叶子节点，则加入vector，然后继续遍历左右子树 else &#123; v.push_back(root-&gt;val); printPathRecur(root-&gt;left, v); printPathRecur(root-&gt;right, v); &#125;&#125;void printPath(TreeNode *root)&#123; vector&lt;int&gt; v; printPathRecur(root, v);&#125; 镜对称（mirror） 12345678void mirror(TreeNode *root)&#123; if (!root) return; mirror(root-&gt;left); mirror(root-&gt;right); swap(root-&gt;left, root-&gt;right);&#125; 双层树（doubleTree） 123456789101112void doubleTree(TreeNode *root)&#123; if (!root) return;; doubleTree(root-&gt;left); doubleTree(root-&gt;right); TreeNode *newNode = new TreeNode(root-&gt;val); newNode-&gt;left = root-&gt;left; root-&gt;left = newNode;&#125; 相同树（sameTree） 12345678910111213141516int sameTree(TreeNode *a, TreeNode *b)&#123; //都为空，返回真 if (!a &amp;&amp; !b) return true; //都不空，则比较 if (a &amp;&amp; b) &#123; return a-&gt;val == b-&gt;val &amp;&amp; sameTree(a-&gt;left, b-&gt;left) &amp;&amp; sameTree(a-&gt;right, b-&gt;right); &#125; else//一个为空一个非空，返回false &#123; return false; &#125;&#125; 是否为二叉树（isBST） 123456789101112131415int isBSTUtil(TreeNode *root, int min, int max)&#123; if (!root) return true; if (root-&gt;val &lt; min || root-&gt;val &gt; max) return false; return isBSTUtil(root-&gt;left, min, root-&gt;val) &amp;&amp; isBSTUtil(root-&gt;right, root-&gt;val, max);&#125;int isBST(TreeNode *root)&#123; return isBSTUtil(root, INT_MIN, INT_MAX);&#125; 完！ ​ Reference: http://cslibrary.stanford.edu/110/BinaryTrees.html 手写笔记：http://blog.chaopengz.top/pdfs/BinaryTreesNotes.pdf （虽然字贼丑，还是要放出来0-0）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[347. Top K Frequent Elements]]></title>
    <url>%2F2017%2F11%2F06%2F347-Top-K-Frequent-Elements%2F</url>
    <content type="text"><![CDATA[Given a non-empty array of integers, return the k most frequent elements. For example,Given [1,1,1,2,2,3] and k = 2, return [1,2]. Note: You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size. 题意：找出出现次数最多的前k个数。 自己的想出来的解法不得不说有点像是诡计：维护一个map[数字] = 出现次数的结构，然后按照value值排序，挑选出前k个的key值。 但是这样的想法遇到一个问题，就是如何对map进行排序。 Google后发现因为map是以红黑树结构来存储数据，以维护其key有序。所以我们需要把map转化为序列存储的vector\后，再调用STL的sort方法对其进行排序。 123456789101112131415161718192021222324252627282930313233343536373839404142//// Created by chaopengz on 2017/11/6.//#include "head.h"class Solution &#123;public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt; &amp;nums, int k) &#123; int len = nums.size(); map&lt;int, int&gt; m; for (int i = 0; i &lt; len; ++i) &#123; m[nums[i]] = 0; &#125; for (int i = 0; i &lt; len; ++i) &#123; m[nums[i]]++; &#125; vector&lt;pair&lt;int, int&gt;&gt; mapVector(m.begin(), m.end()); sort(mapVector.begin(), mapVector.end(), cmp); vector&lt;int&gt; ans; for (int j = 0; j &lt; k; ++j) &#123; ans.push_back(mapVector[j].first); &#125; return ans; &#125; static bool cmp(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) &#123; return a.second &gt; b.second; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集小结]]></title>
    <url>%2F2017%2F11%2F02%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天刷LeetCode 547.Friend Circles 时发现，其就是一道典型的并查集。但是还是不能靠本科学的数据结构知识写出完整的代码，所以就趁机将并查集小结一下，主要参考资料是普林斯顿大学的《Algorithm 4th》。 并查集，顾名思义，就是通过边并边查，把有直接或间接联系的元素都划分到同一个集合里。主要有以下两个步骤： 查（Find）：给定联系p,q，查一查p,q是否已经在同一个集合了。 并（Union）：如果p,q分别在不同的集合里，就合并。 关于查和并这两个的操作主要由三种思路。 快查(Quick-find)：​ 通过维护一个id数组，保存着每个元素所在集合的代表，这样查的时候只要查一查代表是谁就知道两个元素所在集合是不是同一个集合了。如果同在某个集合，则有： id[p]==id[q] ​ 如果不在的话进行合并的时候，就需要把其中某个集合里的所有元素的id值改为另一个集合的代表。如下图所示： ​ Code123456789101112131415161718192021222324252627282930public QuickFindUF(int n)&#123; count = n; vector&lt;int&gt; id; id.resize(n); for(int i = 0 ; i &lt; n ; i++) &#123; id[i] = i; &#125;&#125;pubinc int find(int p)&#123; return id[p];&#125;public void Union(int p,int q)&#123; int pID = id[p]; int qID = id[q]; if(pID==qID) return; for(int i = 0 ; i &lt; n; i++) &#123; if(id[i]==pID) id[i] = qID; &#125; count --;&#125; ​ 查的复杂度：O(1) ​ 并的复杂度：O(n) 快并(Quick-Union)：​ 鉴于快查方法中并的操作复杂度为O(n)，我们就要想方设法降低复杂度。 ​ 这次我们还是维护一个id数组，但是这个数组保存已经不再是集合代表了，而是它的父节点（parent node）。相当于维护一个单向列表（除了根节点要自己指向自己）。 ​ 这样合并的时候只需要将某个集合的根节点指向另一个集合的根节点即可。 ​ 示意图如下： ​ Code:123456789101112131415161718192021222324252627282930public QuickUnionUF(int n)&#123; count = n; vector&lt;int&gt; id; id.resize(n); for(int i = 0 ; i &lt; n ; i++) &#123; id[i] = i; &#125;&#125;pubinc int find(int p)&#123; while(p!=id[p]) p = id[p]; return p;&#125;public void Union(int p,int q)&#123; int pRoot = find(p); int qRoot = find(q); if(pRoot==qRoot) return; id[pRoot] = qRoot; count --;&#125; ​ 查的复杂度O（logn） ​ 并的复杂度O（1） 平衡地并(Weighted quick-union)：​ 上述的做法虽然在一定程度上优化了复杂度。但是对于某些情况，对导致搜索的深度达到O(n)，复杂度还是会比较差。所以要避免这种情况，就还需要继续对上一种做法继续优化。 ​ 快并做法在合并两个集合时某个集合的根节点指向另一个集合的根节点这个完全是随机的。我们可以在这儿优化一下，让小的集合（深度较浅）的指向大的集合的根节点（深度较深），经过这样的优化，合并后的树的深度并没有增加，还是等于原来深度较深的那颗数的深度。 ​ 所以，我们只需要多申请一个数组sz[i]，用来记录以i为根的树已经包含了多少个节点了。然后在合并的时候做下判断后再进行合并即可。 ​ 示意图如下： ​ Code123456789101112131415161718192021222324252627282930313233343536373839404142public QWeightQuickUnionUF(int n)&#123; count = n; vector&lt;int&gt; id; vector&lt;int&gt; sz; id.resize(n); sz.resize(n); for(int i = 0 ; i &lt; n ; i++) &#123; id[i] = i; sz[i] = 1; &#125;&#125;pubinc int find(int p)&#123; while(p!=id[p]) p = id[p]; return p;&#125;public void Union(int p,int q)&#123; int pRoot = find(p); int qRoot = find(q); if(pRoot==qRoot) return; if(sz[pRoot] &lt; sz[qRoot]) &#123; id[pRoot] = qRoot; sz[qRoot] += sz[pRoot]; &#125; else &#123; id[qRoot] = pRoot; sz[pRoot] += sz[qRoot]; &#125; count --;&#125; 看完之后竟然能把LeetCode547的代码一遍无误地敲出来了。看来是看国外的书还是能够深入浅出，默默地思想根植在脑海中。Excited~! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//// Created by chaopengz on 2017/11/6.//#include "head.h"class Solution &#123;public: int findCircleNum(vector&lt;vector&lt;int&gt;&gt; &amp;M) &#123; if (!M.size()) return 0; int n = M[0].size(); count = n; id.resize(n); sz.resize(n); for (int i = 0; i &lt; n; ++i) &#123; id[i] = i; sz[i] = 1; &#125; for (int i = 0; i &lt; n - 1; ++i) &#123; for (int j = i + 1; j &lt; n; ++j) &#123; if (M[i][j]) &#123; Union(i, j); &#125; &#125; &#125; return count; &#125; int Find(int i) &#123; while (i != id[i]) i = id[i]; return i; &#125; void Union(int i, int j) &#123; int p = Find(i); int q = Find(j); if (p == q) return; if (sz[p] &lt; sz[q]) &#123; id[p] = q; sz[q] += sz[p]; &#125; else &#123; id[q] = p; sz[p] += sz[q]; &#125; count--; &#125; vector&lt;int&gt; id; vector&lt;int&gt; sz; int count;&#125;; Reference： https://algs4.cs.princeton.edu/15uf/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《浪潮之巅》摘录]]></title>
    <url>%2F2017%2F11%2F02%2F%E3%80%8A%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85%E3%80%8B%E6%91%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[浪潮之巅吴军2014-11-26 20:53:14 国际商用机器公司 2014-11-26 20:54:15 IBM 仅仅是一个大型计算机制造商， 2014-11-26 20:54:46 它还是世界上最大的开源（Open Source ）的 Linux 服务器生产厂商。 2014-11-26 20:54:53 保守 2014-11-27 17:58:37 很多人奇怪为什么第一个开发出主流 PC（即以英特尔处理器和微软操作系统为核心的 PC）的 IBM 没有成为 PC 之王 2014-11-27 17:59:45 IBM 光靠卖办公机器很难有持续的发展，因此它未雨绸缪，也在找出路。正巧赶上了二次大战，以制造精密机械见长的 IBM 马上把它的生产线民用转军用， 2014-11-27 18:00:11 但是，如果 IBM 仅仅满足于卖机械，我们今天可能就听不到它的名字了。 2014-11-27 18:01:09 电子计算机和 IBM 的名字是分不开的，就如同电话和 AT&amp;T 分不开一样。一方面，IBM 因为有了计算机得以持续发展了半个世纪，另一方面，计算机因为有 IBM 的推广，才从科学计算应用到商业领域和人们的日常生活 2014-11-27 18:01:55 冯·诺伊曼 2014-11-27 18:02:05 毛奇莱（John Mouchly）和艾科特（Presper Eckert） 2014-11-27 18:02:31 埃尼亚克（ENIAC） 2014-11-27 18:03:15 两个人和大学闹翻了，出来成立了世界上第一个计算机公司——艾科特－毛奇莱公司 2014-11-27 18:03:41 计算机，并请来冯· 诺伊曼做顾问 2014-11-27 18:04:23 ，而是将计算机从政府部门和军方推广到民间，将它的功能由科学计算变成商用 2014-11-27 18:05:36 。六七十年代的主流高级程序语言 COBOL 就在这个背景下诞生了。COBOL 的全名为面向商业的通用语言（Common Business Oriented Language）顾 2014-11-27 18:06:31 数字设备公司（DEC） 2014-11-29 12:09:53 ，那么，1976 年可以作为一个分水岭。 2014-11-29 12:10:48 IBM 成功的秘诀是保守，它基本上是不见兔子不撒鹰。如果苹果公司失败了， IBM 不需要做任何事情。如果前者成功了，IBM 依靠它强大的技术储备完全可以后发制人。 2014-11-30 12:57:54 IBM 在和苹果的竞争中真可谓是后发先至。直到今天， IBM PC 还是个人电脑的代名词。 2014-11-30 12:58:19 个人电脑时代的最终领导者是微软和英特尔，而不是 IBM 2014-11-30 12:58:30 2005 年 IBM 将个人电脑部门卖给了中国的联想公司 2014-11-30 12:58:40 IBM 的基因，反垄断的后遗症以及微软的崛起。 2014-12-01 00:13:27 的客户群基本上是政府部门、军方、银行、大企业和科研院校， 2014-12-01 00:14:27 卖掉十万台 PC 可比谈一个大型机合同费劲儿多了。因此，IBM 不可能把 PC 事业上升到公司的战略高度来考虑。 2014-12-01 00:20:42 一方面，自己不愿意下功夫做 PC，另一方面无法阻止别人做 PC，IBM 只好看着康柏（Compaq），戴尔（Dell）等公司作大了。 2014-12-01 00:23:03 ，没有说清楚微软是否可以将 DOS 再卖给别人。盖茨后来抓住了这个空子，将 DOS 到处卖， 2014-12-01 00:24:12 他不会允许别人动微机软件这块大蛋糕，虽然此时的微软的规模远没法和 IBM 相比。盖茨明修栈道，暗渡陈仓，一方面和 IBM 合作开发 OS/2 ，挣了一点短期的钱，另一方面下大力气开发视窗操作系统（Windows） 2014-12-01 00:24:43 虽然 IBM 最先研制出今天通用的个人电脑，但是在从八十年代开始的信息革命中，IBM 不情愿地成为了落伍者。 2014-12-01 00:26:02 IBM 从一个计算机硬件制造公司到一个以服务和软件为核心的服务性公司的转变， 2014-12-01 00:29:25 他的目的是打造一只 IT 服务业的航空母舰。 2014-12-01 00:33:23 服务型的技术公司，并将自己的用户群定位在企业级 2014-12-01 00:33:46 今天，IBM 成为了世界上最大的开源操作系统 Linux 服务器的生产商。 2014-12-01 00:34:02 AT&amp;T 是将一个好好的公司拆散卖掉，IBM 则是将分出去的公司整合回来，打造了一个从硬件到软件到服务一条龙的航空母舰 2014-12-01 00:35:43 一直固守自己的核心领域，很谨慎地开拓新的领域。 2014-12-01 00:36:40 ，因此，即使它的产品和服务比别人贵，政府和公司还是很愿意，或者说不得不用 IBM 的。 2014-12-01 00:36:49 从技术上讲，IBM 是一个极富创新的公司。几十年来，如果说在工业界哪个实验室有资格和贝尔实验室相提并论，恐怕只有 IBM 实验室了。 2014-12-02 00:10:39 。IBM 每年花上亿美元，养了一支庞大的知识产权方面的律师队伍，专门去告那些可能侵犯它们专利的公司，每年 IBM 从专利费上挣来的钱是十亿美元左右 2014-12-02 00:11:51 IBM 的目的是非常清楚的，科研必须和产品相结合。 2014-12-02 00:14:47 IBM 笔记本 Thinkpad 是笔记本电脑的第一品牌， 2014-12-02 00:17:49 IBM 就是这样，时不时地调整内部结构，将一些非核心的、长期效益不好的部门卖掉，同时扩大核心的利润高的生意。 2014-12-02 00:18:26 它在技术上不断在开拓和发展，以领导和跟随技术潮流； 2014-12-02 00:18:42 ，从机械制造到计算机制造，再从计算机制造到服务 2014-12-02 00:20:32 苹果最初是便宜的低端品牌，现在成了高端的时尚品牌， 2014-12-02 00:22:00 没有离开学校，开始旁听他感兴趣的、将来可能对他有用的课。乔布斯没有收入，靠在同学宿舍 2014-12-02 00:23:32 人研制出了世界上第一台通用的个人电脑 Apple-I 2014-12-02 00:24:18 因此，它象征性的意义远比它实际意义要大得 2014-12-02 00:25:04 因此，乔布斯开始致力于研制一种真正能用的个人计算机。1984 年，第二代苹果机麦金托什（Macintosh）诞生了。 2014-12-02 00:25:19 麦金托什是世界上第一种可以买得到的、拥有交互式图形界面并且使用鼠标的个人电脑 2014-12-02 00:27:04 。第二，苹果走了一条封闭的道路，它不允许别人造兼容机，以便独吞 PC 市场。 2014-12-02 00:27:44 —被别人赶出了自己创办的公司，然后又去鬼门关走了一遭。而苹果公司，也开始进入了长达十五年的低谷。 2014-12-02 00:29:31 。乔布斯一气之下，卖掉了他所有的苹果的股票。当时工作站很红火，乔布斯创立了一个做工作站的公司 NeXT，不是很成功。NeXT 工作站的图形 2014-12-02 00:30:01 并把它重构成一个用图形工作站做动画的工作室 Pixar 公司 2014-12-02 00:30:45 。这些项目中，90% 都是没用的。事实证明，所有的项目中最后只有苹果新的操作系统是成功的 2014-12-02 00:32:19 。盖茨说，凭什么你能破窗而入去施乐拿东西，我不可以从门里走到你那里拿东西 2014-12-02 00:33:05 ，再把那个被赶走的创始人请回来执掌公司，不仅以前没听说过，以后也很难再有。 2014-12-02 00:34:01 既然苹果在微机领域已经不可能替代兼容机和微软的地位了，他干脆往高端发展，讲究性能、品味和时尚。慢慢地，苹果的产品成了时尚的东西。 2014-12-02 00:35:06 乔布斯的超人之处在于他善于学习，并且能把得准时代的脉搏 2014-12-02 00:35:31 。乔布斯做了两件事，他在苹果的微机中逐渐采用了英特尔的通用处理器，同时采用 Free BSD 作新的苹果操作系统的内核 2014-12-02 00:36:34 。乔布斯在网络泡沫时代，能高屋建瓴，不去趟互联网这滩浑水，而是看到了网络大潮下面真正的金沙。 2014-12-02 00:37:29 。但是，用户用一个小播放器听音乐和歌曲的习惯已经养成了。 2014-12-02 00:38:03 基于这两点的考虑，乔布斯决定开发被称为 iPod 的音乐和录像播放器。 2014-12-02 00:39:37 苹果没有沉浸在 iPod 的成功中，加 2014-12-02 00:41:19 ，为了将员工的利益和公司的前途绑在一起，发给员工一些股票的期权（Stock Option） 2014-12-02 12:47:08 介绍摩尔定理、安迪-比尔定理和反摩尔定理 2014-12-02 12:47:45 戈登·摩尔 2014-12-02 12:49:51 金融、信息技术（IT）、医疗和制药、能源和日用消费品 2014-12-03 00:11:30 为了能使摩尔定理成立，IT 公司必须在比较短的时间内完成下一代产品的开发。 2014-12-03 00:14:20 软件就用不了，连上网也是个问题。而十年前买得起的车却照样可以跑。 2014-12-03 00:15:00 现在软件开发人员不再像二十年前那样精打细算 2014-12-03 00:16:54 如果微软的开发速度比预期的慢，软件的业绩不好，那么就一定不能买英特尔等公司的股票了。 2014-12-03 00:17:42 今天的手机一般都有两个处理器，一个数字信号处理器（DSP）和一个与微机处理器类似的通用处理器（CPU） 2014-12-03 00:18:31 一个 IT 公司如果今天和十八个月前卖掉同样多的、同样的产品，它的营业额就要降一半。IT 界把它称为反摩尔定理。反 2014-12-03 00:21:33 大公司们，除了要保持很高的研发投入，还要时刻注意周围和自己相关的新技术的发展，经常收购有革命性新技术的小公司 2014-12-04 13:12:43 在美国西海岸旧金山到圣荷西市（San Jose）之间，围绕着旧金山海湾有几十公里长，几公里宽的峡谷，通常称为硅谷 2014-12-04 13:13:07 ）那里之所以叫硅谷并不是因为它生产硅，而是它有很多是使用硅的半导体公司，包括全世界最大的半导体公司英特尔公司 2014-12-04 13:14:05 尤其是有微软这个强势的伙伴； 2014-12-04 13:16:27 IBM 为了短平快地搞出 PC，也懒得自己设计处理器，拿来英特尔的 8086 就直接用上了。这一下子，英特尔一举成名 2014-12-05 11:11:21 八十年代，英特尔果断地停掉了它的内存业务，将这个市场完全让给了日本人，从此专心做处理器 2014-12-06 00:18:12 。英特尔靠 80386 完成了对 IBM PC 兼容机机市场一统江湖的伟业。 2014-12-06 00:20:42 ，英特尔公司不再以数字命名它的产品了，但是在工业界和学术界，大家仍然习惯性地把英特尔的处理器称为 x86 系列。 2014-12-06 00:22:17 资金密集型的日本半导体公司终究不可能是技术密集型的英特尔公司的对手 2014-12-06 00:30:15 据指令集合分成复杂指令（CISC）和简单指令（RISC）两种 2014-12-06 00:43:30 英特尔经过十年努力终于打赢了对精简指令集的处理器之战。需要强调的是，英特尔不是靠技术，而是靠市场打赢的此战。 2014-12-06 00:46:08 。而今天，英特尔和 AMD 之间争夺市场的竞争我个人认为不是一个重量级对手之间的比赛，因此算不上是战争。我想，如果不是反垄断法的约束，英特尔很可能已经把AMD击垮或者收购了 2014-12-08 21:48:00 因此，今后处理器设计必须考虑能耗。 2014-12-09 12:48:51 我个人认为，在个人微机以外，今后最重要的市场是游戏机市场。现 2014-12-09 12:50:50 它的发展很大程度上必须依赖于微软等公司软件的更新 2014-12-09 12:51:48 但是今后除非它能找到新的成长点，否则它会随着 PC 时代的过去而进入自己平和的中老年期。 2014-12-09 12:52:52 作为补救，将强制地把微软拆成两个公司，一个操作系统的公司和一个经营其它软件的公司 2014-12-09 12:53:25 微软作为计算机领域生态链最上层的一个环节一方面刺激着整个计算机领域的发展，另一方面微软扼杀了无数具有创新的大大小小的公司 2014-12-09 12:55:20 在计算机领域双雄的第一次交手中，乔布斯在合同上得到了一些小便宜，但是，盖茨才是真正的胜利 2014-12-09 12:56:35 直到1990年微软发布Windows3.0并称为软件霸主时，它的营业额才达到苹果同时期的五分之一。乔布斯不是神仙，很难料到比自己小得多的微软以后会威胁到自己。 2014-12-09 12:57:18 在这次双雄会上，乔布斯犯下的错误有两方面，首先，他自己没有意识到操作系统在今后整个微机工业中的重要性，否则他不会过早地给别人看他还没上市的设计；第二，也是更重要的，他给谁看都可以，就是不该给盖茨这个人看 2014-12-09 12:57:56 到只要垄断了操作系统，就间接垄断了整个行业，因为操作系统和别的软件不同，是在买计算机时预装好了的，一般用户没有选择 2014-12-09 12:58:34 让盖茨和乔布斯生于同一时代是一件很遗憾的事，因为他们两个人注定要有一人成为失败者。在技术嗅觉上，乔布斯好于盖茨，但是，在商业眼光和经营上，盖茨要强于乔布斯。 2014-12-09 12:59:39 盖茨从来是个置于死地而后生的人，早在哈佛大学读书时，他就是这样 2014-12-09 12:59:58 。Altair公司倒很认真，要来看看盖茨的东西。盖茨和艾伦等人居然在几星期内赶制出来了一个 2014-12-09 13:00:31 一个配角，而必须夺得操作系统的控制 2014-12-09 13:01:13 ，但是微软还是答应了，因为这样一来可以借助IBM的力量锻炼队伍，二来可以制约苹 2014-12-09 13:02:36 第三步棋，微软暗地里偷偷地、非常低调的学习苹果悄悄开发Windo 2014-12-09 13:03:38 最后，盖茨的诚意和微软的股票期权打动了Allchin。 2014-12-09 13:04:35 如果说盖茨是微软这条巨轮的船长，那么鲍尔默则是开船的大副。 2014-12-09 13:05:24 免费的BASIC和五美元预装的DOS其实是微软的一个钓饵，它是为了吸引软件公司和计算机爱好者在上面开发出各种各样的软件，使用户产生对微软的依赖。 2014-12-09 13:07:24 一位日本围棋国手讲过，高手过人取胜之道，就在于抓住对手的失误。 2014-12-09 13:08:04 结果是，苹果好处抢得快，微软大局布得好。 2014-12-09 13:09:03 但是，领先下的苹果犯了一个致命的错误—走封闭式道路和纯技术路线。 2014-12-09 13:10:19 但是由于IBM PC的开放性特点和信息工业全球化的效应，使得IBM兼容机越做越便宜，市场占有率越来越高，DOS在操作系统占有率上便领先于苹果。 2014-12-09 13:11:39 如果说苹果抢到了天时，那么，微软通过开放、兼容和廉价则夺回了地势。 2014-12-09 13:12:14 一种操作系统成功与否，最终要看上面有多少既有用又廉价的应用软件 2014-12-09 13:12:57 苹果另外一个不容忽视的失误就是兼容性 2014-12-09 13:13:47 虽然它的在长达九年的时间里只有DOS这个大刀长矛，却靠广大的用户基础占住了脚。 2014-12-09 13:13:58 苹果失去地利的一个更深层的原因是它在某种程度上违反了信息领域的摩尔定理和安迪-​ 比尔定理。整 2014-12-09 13:14:31 这时，用户不是抱怨软件做的不好，而是去更新硬件。 2014-12-09 13:14:45 苹果既做硬件又做软件，很难平衡两者的速度。 2014-12-09 13:15:53 虽然大家都知道人才的重要性，但是至少从表面上看，盖茨比较礼贤下士，而苹果比较傲士。 2014-12-09 13:16:31 而苹果当时正处在历史上最混乱的时期，竟然组织不起一次有效的反击便一溃千里。微软终于靠十年的人民战争夺得了微机操作系统的统治地位。 2014-12-09 13:17:58 垄断操作系统只是盖茨营建IT帝国的第一步。微软在一统操作系统的天下后，已经没有后顾之忧了，便接连打出三记重拳，干净利落地消灭了莲花公司，WordPerfect公司和网络界新星网景（Netscape）公司，夺 2014-12-09 13:18:44 盖茨作为微软的统帅，表现出了超人的胆识、魄力和指挥艺术 2014-12-09 13:19:13 通用的网络浏览器，1 2014-12-09 13:19:46 在于它控制了人们使用计算机时无法绕过的接口-操作系统 2014-12-09 13:20:04 现在，网景控制了人们通向互联网的接口 2014-12-09 13:21:00 后来证明这种技术上的优势根本不可靠，这也是我将技术排在形成垄断的三个条件之外的原因。 2014-12-09 13:21:45 盖茨让很多工程师立即停掉手里的工作，不管做到那个阶段，然后全力投入微软浏览器IE的开发 2014-12-09 13:22:01 盖茨的这种魄力我以后只在佩奇和布林身上又看到过一次，而 2014-12-09 13:22:15 盖茨动用了他的杀招-和Windows捆绑，免费提供给用户。很快，网景就被垄断了操作系统的微软 2014-12-09 13:23:22 但是，盖茨否认微软是个垄断公司，并且狡辩说IE不是一个单独的软件，而是Windows的一个功能。 2014-12-09 13:24:07 多年后，佩奇在总结网景教训时为网景找到了一个可以在微软垄断的压力下生存的办法，我们在介绍佩奇时再讲。 2014-12-10 16:22:53 。微软人才济济，盖茨则是领头狮，他对内统领群雄，对外无往不利，对微软帝国的建立起了至关重要的作用 2014-12-10 16:23:01 如果用最简练的语言概括他就是两个字—平衡 2014-12-10 16:23:09 保守和冒险的平衡。 2014-12-10 16:23:24 靠落后的DOS，靠十年的持久战取 2014-12-10 16:23:44 雅虎前CEO塞缪尔是如何大张旗鼓地吹嘘雅虎的新项目帕拿马，从而断送雅虎的 2014-12-10 16:24:21 盖茨非常聪明地从西雅图计算机产品公司SCP买下了DOS，但是没有讲其实是IBM要，所以买价只有区区七万五千美元（也有说是五万元 2014-12-10 16:25:43 盖茨是个既心比天高却又脚踏实地的 2014-12-10 16:25:58 即使在微软还很小时，他就努力将它按百年老店来办 2014-12-10 16:27:50 总之，盖茨做的每一件事，都是针对全世界所有人的，这样才能达到聚沙成塔的效果 2014-12-10 16:28:00 而实现他改变世界的理想的工具则是盖茨基金会。 2014-12-10 16:32:11 盖茨和那些真正的将毕生积蓄无条件捐给他人而不是自己的基金会的那些真正的慈善家是不同 2014-12-10 16:32:31 我很敬重投资大师巴菲特，他毕生生活简朴，老了以后，只给自己的孩子 2014-12-10 16:32:35 ，一笔超过三百亿美元的巨款无条件地捐给了盖茨基金会 2014-12-10 16:32:45 只不过是盖茨通过它来实现自己改良世界的理想的机构，以及将财富传给子孙万代的避税港 2014-12-10 16:32:56 如果说乔布斯是锋芒毕露，聪 2014-12-10 16:33:00 写在脸上；盖茨就是一个平衡木冠军，聪明藏在肚子里 2014-12-13 18:21:02 苹果是微机的首创者，是微机工业文化的发源地。罗马从希腊学到了很多东西，然后打败了老师，它建设强大的帝国和美丽的城市，但它的创新并不多。 2014-12-13 18:22:23 现在让我们再回到现实。整个九十年代可以说是微软的十年 2014-12-13 18:22:40 。很明显，全球下一个金矿就是互联 2014-12-13 18:23:11 虎成功地阻击了微软，使得后者远离互联网领 2014-12-13 18:23:29 免费提供和对手竞争的产品。但是这一招对雅虎不灵，因为雅虎的服 2014-12-13 19:03:17 即让内容的提供商出钱（早期要把新闻放到雅虎上是要向雅虎交钱的）并且为大的公司做品牌广告。 2014-12-13 19:05:01 总的来讲，微软的脑筋还停留在一份份卖软件的微机时代，在开拓网络服务方面亦步亦趋。 2014-12-13 19:05:28 这再次印证了微软的基因决定了它不容易适应互联网时代。 2014-12-14 08:53:40 由于雅虎各种服务是免费的，收入并不高，利润更少的可怜。但是，华尔街认定雅虎代表未来，将雅虎的股票追捧的很 2014-12-13 19:06:20 成 2014-12-14 08:56:07 。他从不管华尔街说什么，只要是看准了的事就只争朝夕的 2014-12-14 08:56:53 我非常喜欢黑格尔地一句话：凡是现实的都是合理的，凡是合理的都是现实的。(All that is real is rational; and all that is rational is real.)虽 2014-12-14 09:16:54 微软称雄于微机时代，自有它的合理性。但是，到了网络时代，显示改变了，微软再次称雄的合理性也就没有了。 2014-12-14 09:18:19 是一个工具，微软要把它变成家庭娱乐中心，从而控制每一个家庭的娱乐活动。 2014-12-14 09:19:45 看相同节目的用户只送出一份以节省带宽，这是思科的特长 2014-12-14 09:20:48 我们前面提到，盖茨是一个心比天高的人，他的野心常常超出一般人的想象。 2014-12-14 09:21:24 如果微软的想法得以实现，它将改变整个电影电视和其它娱乐业的生态链 2014-12-14 09:21:18 而微软将再次做到这个生态链的龙头位置。 2014-12-14 09:22:33 微软只用的短短的十几年就建成了一个IT帝国，而以前AT&amp;T和IBM则用了半个世纪才办成同样的事。 2014-12-14 09:25:33 但是，个人微机的这次浪潮还没有过去，处在其浪潮之巅的微软即使不做任何事，仍然是世界上最赚钱的公司。它 2014-12-14 09:26:11 客厅信息化是否能形成下一次技术革命的浪潮，而它又是否能在客厅争夺战中最终胜出。 2014-12-14 09:29:48 没有思科和同类公司生产的路由器就没有今天的互联网，那么大家就知道思科在我们生活中的作用了 2014-12-14 09:30:46 ，同时他将自己的工资降到每年一美元，成为世界上工资最低的 CEO。这种做法一度被传为佳话，并纷纷为那 2014-12-14 09:31:05 和惠普、太阳、雅虎、谷歌等公司一样，思科是一个标准的斯坦福公司。 2014-12-14 09:32:33 干脆发明了一种能支持各种网络服务器、各种网络协议的路由器。于是思科赖以生存的“多协议路由器”便诞生了。 2014-12-14 09:32:55 。但是，由于不同网络设备厂家采用的网络协议，每个公司都要推广自己采用的协议，没有公司愿意为其它公司做路由 2014-12-14 09:34:08 思科公司的图标正是旧金山的金门大桥，创始人的意思是要建起连接不同网络的桥 2014-12-14 09:34:31 。红杉风投投资喜欢投给年轻的穷人，因为越是穷人越有成功的欲望和拼搏精神。 2014-12-14 12:44:43 当然，思科能坐稳网络设备供应商的头把交椅，很大程度上取决于它非常特殊的文化。 2014-12-14 12:52:00 如何留住早期员工，并且调动他们的积极性，便成为了每一个上市的科技公司的难题。 2014-12-14 12:52:33 因此，有些员工一旦有了好的想法，宁可自己出来创业，也不愿贡献给自己的公司。这两个问题在硅谷普遍存在，而思科是这些问题解决得最好的公司。 2014-12-14 12:53:10 ，如果公司里有人愿意自己创业，公司又觉得他们做的东西是好东西，就让他们留在公司内部创业而不要到外面去折腾，而思科会作为投资者而不再是管理者来对待这些创业的 2014-12-14 12:55:39 领袖都有思科 CEO 钱伯斯（John Chambers）的胸怀和远见卓识，更重要的是思科的基因使然。思科自己的创建就是用到了两个创始人的职务发 2014-12-14 12:56:25 托尔斯泰讲，幸福的家庭都是相似的，不幸的家庭各有各的不幸。在信息工业中，这句话要反过来讲，成功的公司各有各的绝招，失败的公司倒是有不少共同之处。 2014-12-14 12:58:07 而且，美国很多政府部门和大公司在采购时要求必须从两个以上的厂家中挑选，因此，思科为了做生意以必须允许 Juniper 的存 2014-12-14 12:58:18 思科真正的对手是中国的小弟弟华为 2014-12-14 12:59:35 华为创办时起点就很高，当时邮电部下面的一些研究所还在和 AT&amp;T 等跨国公司谈二流技术的转让和合作，任正非直接就定位当时国际上最先进的技术，并且短短几年就开发出了当时具有国际先进水平的 08 程控交换机 2014-12-14 13:00:21 虽然目前华为的市场占有率按营业额计算只有思科的四分之一，但是前途不可限 2014-12-14 13:01:28 更重要的是华为将思科拖入了“中国制造”效应的阴影中，这是后者极不愿意的 2014-12-14 13:02:18 因为华为已经可以生产和思科匹敌但是价格便宜许多的低端网络设备， 2014-12-14 13:02:57 当然，思科在高端产品和新产品上的优势是华为短期内无法相比的，但是，如果一个公司只剩下高端产品，那么它就在也不能成为全行业的垄断者。 2014-12-14 13:04:37 令思科烦恼的是，华为这个“小公司”追赶自己的速度快的惊人，这主要是因为华为比思科灵活得 2014-12-14 13:05:12 华为可能是中国目前在 IT 行业唯一可以和世界上的行业老大竞争的公司，这很大程度上因为华为从公司结构和经营上已经和美欧上市公司没有什么差别，同时华为有一位了不起的统帅任正非。任正非，作为一个创造者和巨人（Bu 2014-12-14 13:05:52 华为唯一要注意的是避免亚洲家族企业从兴到衰的宿命。 2014-12-14 13:06:16 在互联网行业，服务型公司谷歌和雅虎等会先起步，然后带动网络设备公司的业绩 2014-12-14 13:07:16 当一个公司的市场占有率超过 50% 以后，就不要再指望在市场占有率上翻番了 2014-12-14 13:11:01 它的营业额并不能因为多买了一些设备而常比例的提升。因此，除非它能开拓出新的市场，否则会成为下一个朗讯。要 2014-12-14 13:31:06 那样。这时，每个人和家庭的表示是 IP 地址，当然，网络路由器代替了原来程 2014-12-14 13:32:43 Skype 为了保证一个电话语音数据包能及时地传递到对方，它会将该包复制多份通过互联网上的多条线路进行传送，这种霸道的做法效率其实非常 2014-12-14 13:41:44 在 VoIP 和网络上影视传输设备领域，思科最有可能成为这个市场的领头羊，这样它就可以在互联网浪潮之后，再次搭上宽带通信革命的浪潮。 2014-12-14 13:41:59 将市场主动让给华为等“中国制造”的公司，保守地开拓新领域的成长点， 2014-12-14 13:42:37 对互联网贡献最大的人，那么这两个人很可能是杨致远和费罗（David Filo）。他们对世界的贡献远不止是创建了世界上最大的互联网门户网站雅虎公司，更重要的是制定下了互联网这个行业全世界至今遵守的游戏规则—开放、免费和盈利。 2014-12-16 18:33:17 一个产业早期领导者选定的商业模式对这个产业几乎是决定性的。雅虎不是第一家从事互联网服 2014-12-16 18:33:35 但是，雅虎是确定互联网行业商业模式的公司，并且是主流免费门户网站的真正代表 2014-12-17 22:51:14 为什么雅虎能够把互联网办成开放和免费的呢？因为它的创始人杨致远和大卫费罗一开始搞互联网就不是为了盈利， 2014-12-17 22:51:26 习网络的，但他们和另一个同学搞起雅虎完全是出于对互联网有非比寻常的兴趣。1994年，三个人乘着教授去学术休 2014-12-17 22:56:52 。首先订下了互联网这个行业的游戏规则—开放、免费和盈利（这一点我们下面要专门讲 2014-12-18 20:46:30 ；第三个办法就是把互联网自己从最初的非赢利性质变成为盈利的，刺激电子商务的发展，从电子商务和广告中挣钱来维护和运营互联 2014-12-18 20:49:26 不是所有的流量都是平等的”。2000年以前，电子商务实际上 2014-12-18 20:57:21 -新的CEO塞缪尔（Terry Samuel）和首席财务官德克尔（SueDecker） 2014-12-19 12:15:05 文过饰非， 2014-12-19 18:58:11 AT&amp;T，每家都有最优秀的领导人，比如IBM的郭士纳、微软的盖茨和鲍尔默、英特尔的格罗夫和思科的钱伯 2014-12-19 18:58:41 Google还只是一个几个人的小公司。但是，公司的大小不能完全保证今后竞争的结果；而公司的基因起得作用更多。 2014-12-19 19:01:11 当然所有的技术都有自己的局限性和不足，一个崇尚技术的公司的态度是解决这些问题而不是倒退到手工操作。至今，雅虎仍然会手工地调整搜索 2014-12-19 19:02:13 在Google，工程师的地位非常高，最高级别的写程序的工程师可以享受全球副总裁的待遇 2014-12-19 19:04:58 。大公司提高效率不仅仅是提供一些免费午餐这么简单，首先要能打破山头，打破部门界限，协调合 2014-12-19 19:12:13 对华尔街来讲，并不在乎谁是互联网的主宰，利润对它们来讲是第一 2014-12-19 19:14:01 但是，如果雅虎换一种思维方式，回到它传统的传媒领域，在技术上和Google合作，则很可以作为一个强势的媒体公司屹立在互联网 2014-12-19 19:17:10 ，从戴尔（DELL）公司手中重新夺回世界微机厂商的头把交椅。但是惠普性质已经由一个高科技公司变成了一个以家电为主的消费电子公司了。 2014-12-19 19:19:35 叫特尔曼 2014-12-19 19:19:55 斯坦福工业园（Stanford 2014-12-19 19:24:16 惠普衰落的原因大致有两个，领导者的错误和“日本/中国制造”的冲击。 2014-12-19 19:26:12 惠普很多产品之间毫不相干，无法形成优势互 2014-12-19 19:28:55 ，一个计算机硬件公司必须发展超过摩尔定理规定的速度才有意义，否则，利润将一 2014-12-19 19:33:16 改造自身，提高竞争力，IBM 的郭士纳和英特尔的格罗夫，包括惠普后来的 CEO 赫德就是这么 2014-12-19 19:45:54 当然，摩托罗拉对世界最大的贡献是它在八十年代初发明的民用蜂窝式移动电话，也就是早期说的大哥大，现在说的手机 2014-12-19 19:49:38 。GSM 的技术核心是时分多址技术（TDMA），即将每个无线频率均匀地分给八个（或者十六个）手机用户，每个用户交互地占用八分之一的信道时间。（ 2014-12-19 19:58:33 摩托罗拉和 AT&amp;T 衰落的原因正好相反。 AT&amp;T 由于没有一个能控股的股东，没有人觉得公司是自己的，并为它的长远利益考虑，于是董事会的短视和贪婪断送了它。而 2014-12-19 20:00:52 11.1 成王败寇 2014-12-19 20:01:30 。硅谷还拥有世界上顶级专业数量排名前两名的大学斯坦福大学和伯克利加大（UC Berkeley）。 2014-12-19 20:10:07 了，这些创业者也就默默无闻了。人们从来就是只记得住英雄的名 2014-12-19 20:10:36 首先，创始人很重要。任何梦想家都不足以成事，因为所有的成功者都是实干家。 2014-12-19 20:15:26 成功的创业者必须有一个小而精的好团队，里面每个人都得不计较个人得失，同甘共苦，否则成则争功，败则互相推诿。在技术上，他们必须有自己的金刚钻，他们的技术必须是不容易被别人学会和模仿的。如果看到雅虎挣钱，就去搞网站，那基本上可以肯定是要失败的。 2014-12-19 20:16:56 他们有商业头脑而且必须找到一个能盈利的商业模型（Business Model）。Ebay 和谷歌的成功很重要地在于它们 2014-12-19 20:19:50 执行力是保证正确的决定能够最终实现的因素 2014-12-19 20:19:56 判断力和执行力很大程度上来自于经验 2014-12-19 20:41:07 上还要看外部环境 2014-12-19 20:41:04 不好，很多很有 2014-12-19 20:41:00 最后，也是最重要的，创业者必须有好运 2014-12-19 20:47:15 。根据美国证监会的规定，一个公司上市后员工（包括创始人自己）的股票在 180 天以后才能 2014-12-19 20:50:32 ，一将功成万骨枯，无数失败的公司在为少数几个成功者做分母 2014-12-19 20:59:41 当然，如果只是工作时间长一些，还可以忍受。硅谷失业的压力要比美国其它地区大得多。 2014-12-24 21:12:20 比如著名的投资银行高盛公司（Goldman Sachs），有超过 10% 的个人财产管理经理人都在硅谷，使硅谷成为全球仅次于其纽约总部的第二大分公司 2014-12-25 17:28:11 想反，如果一个人不能脚踏实地做点实实在在的事情，即便名气再大，才高八斗，在硅谷也很难混下去。大多数时候，硅谷公司需要的是能真正做事情的人，而不太看重那些不能带来实际效益的名气 2014-12-25 17:30:52 的）尽管现在仙童公司早已江河日下了，但是每一个计算机用户一定知道它的两个孩子—英特尔公司和 AMD 公司。 2014-12-25 17:31:14 ，硅谷著名的大公司有：惠普，英特尔，Sun，SGI，IBM （Almaden），甲骨文（Oracle），苹果，3Com， Seagate，AMD，国家半导体（National Semicondu 2014-12-25 17:31:32 。2000 年后，硅谷最大的公司是思科，谷歌，英特尔，IBM，甲骨文，苹果，惠普，雅虎，基因科技（Genentech）和 Eba 2014-12-25 17:33:02 只是硅谷的核心产业越来越远离半导体 2014-12-25 17:33:47 造成硅谷半导体衰退的直接原因有两个，首先是反摩尔定理的效应。由于 2014-12-25 17:33:50 其次是“亚洲制造”效应，由于硅谷靠半导体和计算机硬件起飞，在七十年代它 2014-12-25 17:35:05 硅谷真正的本质。硅谷的灵魂是创新。硅没有了，创新的灵魂留下了，它保证了硅谷的繁荣和发展。 2014-12-25 17:35:30 虽然有些投资者为自己错过英特尔的机会而惋惜，但是，人们很快在硅谷找到了新的金矿——软件业。 2014-12-25 17:36:35 。同时（在企业级市场上）证明这一点的，就是甲骨文公司。在甲骨文和微软以前，计算机软 2014-12-25 17:39:10 值得一提的是，以 Google 和 Yahoo 代表的互联网公司，颠覆了以微软代表的软件公司 2014-12-25 17:41:02 。在美国，除了像西洋参和卵磷脂那样的保健品外，药品分为两类，一类是处方药比如抗生素，另一类是非处方药比如治感冒的 2014-12-25 19:20:53 创新必须依靠技术实力。和 Google 一样，基因科技也是世界上单位办公面积博士密度最高的公司。就连它 2014-12-25 19:22:02 。遗憾的是辉瑞旧式的体制恰恰做不到这一点，而基因科技完全按照IT公司的模式经营，却做到了这一点。 2014-12-25 19:22:36 科技公司的期权制保证了各级雇员除了工资以外，可以从公司的利润中分到一杯 2014-12-25 19:23:01 员工从股票上的收益可以大于自己的工资，这就是大家拼命干活的动 2014-12-25 19:24:14 。但是它绝不会像底特律和匹兹堡那样从此衰落下去，而仍然会是世界科技之都，因为硅没有了而创新留下来 2014-12-25 19:27:26 Google 的一千七百亿美元、和排名第三的 IBM 的一千六百亿美元 2014-12-25 19:28:18 。太阳公司从 1982 年成立到 2000 年达到顶峰用了近二十年时间，而走下坡路只用了一年，足以令经营者为戒。 2014-12-25 19:28:32 太阳公司名称的由来很多人不知道，它其实是斯坦福大学校园网（Stanford University Network）的首字母缩写 2014-12-25 19:30:26 （RISC） 2014-12-25 20:08:01 这样，高端微机取代低端工作站和小型机进入企业级市场的时机就成熟了，企业级的霸主的争夺战就在微软和太阳之间展开 2014-12-25 20:10:25 。我们不能不承认，微软的管理团队是当时世界上 IT 领域最好的，比尔盖茨当年也是最棒的工业界领袖。 2014-12-25 20:11:41 马可尼里领导的太阳公司在很长时间里甚至没有看出决战操作系统的重要性，这样太阳公司和微软公司的竞赛还没有开始就先输了第一回 2014-12-25 20:13:33 。施密特当时是太阳公司主管软件的副总裁，他从太阳失败的教训中总结出了反摩尔定理，我们已经介 2014-12-25 20:14:37 事实证明，微软虽然是IT史上最可怕的对手，但是并非无懈可击。历史上甲骨文 (Oracle)、Intuit(Turbo Tax)、Adobe 和 Yahoo 以及今天的 Google 都在自己的领域打败了微软 2014-12-26 12:11:51 （而不是服务业务）为主的商业模式使得它不可能开源 Solaris，因为它主要的钱来自于硬件。（正是这个道理，苹果也不可能把它的 iPhone 操作系统开源 2014-12-26 12:12:45 但是太阳公司最有意义的发明是至今没有给太阳公司带来什么经济效益的 Java 程序语言。太阳公司第三个遗憾之处就是没有能将 Java 间接地转化成利润。 2014-12-26 12:19:31 太阳公司不缺乏英才，但是它平庸而大锅饭式的管理实际上是在进行劣胜优汰。太阳公司很多人离开后都比在太阳干得出色得多，其中包括 Google 的 CEO 施密特和 Juniper 的共同创始人 Bjorn Liencres 以及 Google 早期很多资深的工程师 2014-12-27 18:07:05 太阳公司犯下的第二个致命错误就是没有将太阳与微软的操作系统之争和互联网开发工具之争放在和 HP、DEC 等服务器公司市场争夺之上 2014-12-27 18:09:41 也许 Google 从太阳的失败中吸取了教训，和以往大多数网站都希望其它网站关门自己独大不同，Google 一直在帮助其它网站共同发展，分享利润 2014-12-28 21:51:21 事实证明，网景在技术上的优势是根本靠不住的。我们在前面的章节中已经多次介绍了技术领先的产品在商业上失败的例 2014-12-28 21:57:49 传统上创业资金的合法来源只有两种渠道：一种是靠积累（比如继承遗产或者是自己多年的积蓄），第二种是靠借贷（比如从家人、亲戚和朋友那里凑钱，或者从银行抵押贷款 2014-12-28 21:58:51 处。风险投资不需要抵押，也不需要偿还。如果投资成功，风投资本家将获得几倍、几十倍甚至上百倍的回报，如果不成功，钱就打水漂了 2014-12-28 22:05:10 。美国人不怕失败，也宽容失败者。大家普遍相信失败是 2014-12-28 22:08:39 风险投资基金（Venture Capital Funds）主要有两个来源：机构（Institutes）和非常有钱的 2014-12-28 22:11:56 公司（Limited Liability Company， LLC）。为了避税，在美国融资的基金一般注册在特拉华州，在世界上其它地区融资的基金注册在开曼群岛（Cayman Islands）或者是巴哈马(Bahamas)等无企业税的国家和地区 2014-12-29 08:06:00 。风险投资公司自己扮演一个称作总合伙人的角色（General Partner），其它投资者称为有限合伙人（Limited Partner）。总合伙人除了拿出一定资金外，同时管理这一轮风险基金。有限合伙人参与分享投资回报但是不参加基金的决策和管 2014-12-29 08:43:20 管理风投基金的风投公司本身也是个 LLC，其最高管理者就是风投公司的合伙人了（Partner 2014-12-29 08:46:57 ；而另一方面，新成立的公司本身都很小，尤其是初期，它们只需要融资几十万甚至几万美元就可以了，大风险投资公司就不会参与。对于这些公司的投资就由一类特殊的风险投资商——天使投资人来完成。 2014-12-29 08:48:49 科技公司（Startups） 2014-12-29 08:49:59 （关键之一，知识产权很重 2014-12-29 08:50:13 倍（关键之二，是否有数量级的提高是衡量一项新技术是革命性的还是革新性的关键。 2014-12-29 08:50:59 （关键之三，商业计划很重要）。 2014-12-29 08:55:53 ，它们并没有相应的资金或者技术做抵押，这些股票的存在实际上稀释了（Dilute）所有股东的股权。为什么公司自己要印这些 2014-12-29 08:56:01 1.由于山姆等人的工资很低，他们将根据自己的贡献，拿到一部分股票作为补偿； 2014-12-29 08:56:06 2.公司正式成立后需要雇人，需要给员工发股票期权； 2014-12-29 09:06:26 一般来讲，一个创始人在公司上市时还能握有 10% 的股份已经很不错了。 2014-12-29 09:08:18 。我们从这个例子中可以看到，风险投资必须是渐进的，在每一个阶段需要多少钱投入 2014-12-29 09:08:37 ，早期的公司股价都不会高，过早大量融资会使得自己的股权占得太低，自己不但在经济上不划算，而且还会失去对公司的 2014-12-29 09:12:02 ，我们忽略了两个关键性的问题：风险投资公司如何决定是否投资一个公司（或者一个产业），以及如何决定一个小公司的价值 2015-01-04 00:54:07 一个价值不超过一亿美元的公司是无法在美国上市的 2015-01-04 01:02:07 一个好的创业题目最要紧的是具有新颖性，通常是别人没想到的，而不是别人已经做成功的。 2015-01-04 01:04:52 我通常把科技进步和新的商业模式分成进化（Evolution）和革命（Revolution）两种，虽然它们的英文单词只差一个字母，意义可差远了。创业必须要有革命性的技术或者革命性的商业模式。 2015-01-04 01:12:59 这也是著名风险投资公司比小投资公司容易成功的原因之一，前者手中攥着更多更好的管理人才。 2015-01-04 01:13:56 。因此，大多数想去小公司发财的人，选择公司很重要的一个原则就是看它幕后的风投公司的知名度。Googl 2015-01-04 01:14:20 创始人的魅力，但是还有非常重要的一条就是它是第一家KPCB和红杉风投在同一轮一起投资的公司，在此以前 2015-01-05 00:24:35 如果投资者站到了前台，要么说明创始人太无能，要么说明投资人手伸的太长， 2015-01-11 09:26:45 一些短视的创业者把风投公司当作一次性免费提款机，只拿钱而不承担应尽的义务，实际上便永远地断了自己的后路 2015-01-11 09:27:07 在创业者眼里“沙丘路”（Sand Hill Road）便是风险投资公司的代名词 2015-01-11 09:29:14 红杉风投是迄今为止最大、最成功的风险投资公司。它投资成功的公司占整个纳斯达克上市公司市值的十分之一以上，包括苹果公司、Google 公司、思科公司、甲骨文公司、Yahoo 公司、网景公司和 YouTube 等 IT 巨头和知名 2015-01-11 09:30:46 第一、被投公司的技术必须有跳变（用红杉风投自己的话讲叫做 Sudden Change），就是我常说的质变或者革命 2015-01-11 09:31:01 第二、被投公司最好处在一个别人没有尝试过的行业，即是第一个吃螃蟹的人 2015-01-11 09:31:25 1.公司的业务要能几句话就讲得清 2015-01-11 09:32:23 形成，优秀创始人才能吸引优秀的团队，优秀的团队才能奠定好的公司的基础。 2015-01-11 09:33:39 KPCB 成功投资了太阳公司、美国在线（AOL）、康柏电脑、基因科技、Google、Ebay、亚马逊（Amazon）和网景等著名公 2015-01-11 09:35:21 。我对风险投资家的敬意远远高于对华尔街，因为风险投资对社会有很大的正面影响，而华尔街经常会起负面作用（最 2015-01-11 09:37:19 这里面的百分比数字 70、20 和 10 是我加的，因为信息产业大公司之间的市场份额大抵如此。 2015-01-11 09:41:58 彼得·诺威格博士（Peter Norvig）讲，当一个公司的市场占有率超过 50% 后，就无法再使市场占有率翻番了。这几乎是任何人都懂的大白话，但是却道出了许多跨国公司兴衰的根 2015-01-11 09:46:28 。显然，Google 的所做所为没有超过原有的广告工 2015-01-11 10:31:49 IBM 的商业模式是将长期的服务捆绑到系统销售中，至今依然如此。应该讲，IBM 的商业模式是一个很好的模 2015-01-11 20:12:19 作为投资者，华尔街最希望看到的是 IBM 安心做它的系统和服务，微软老老实实卖 P C软件，Google 和雅虎来负责互联 2015-01-11 20:14:49 对微软来讲，功能比时尚更重要，因此它开发 Windows 的过程是一个严格的自顶向下的过程 2015-01-11 20:15:59 。苹果的基因决定它必须通过硬件挣软件的钱。创新是苹果最关键的基因，否则它存在的意义就不大了。至于在什么地方创新，苹 2015-01-11 20:17:37 的钱，而只是希望人们通过硬件来使用它的搜索。因此，它希望采用它的 Android 手机操作系统的制造商越多越好。由于诺基亚和 Google 的基因不同，商业模式不同，在手机领域的做法就会不同，当然最后的结果也会不同。 2015-01-11 20:21:25 埋没掉赶不上大潮的失败者。 结束语 2015-01-11 20:21:51 。很多当今世界上 IT 领域的领头公司都是由斯坦福大学的学生和教授创办的。它们包括惠普公司、思科公司、太阳公司、雅虎公司、Google（谷歌）公司、英特尔公司、制造处理器和工作站的 MIPS 和 SGI 公司、世界最大的显卡公司 Nvidia、世界最大的视频电话会议公司 Webex 等，另外在非科技领域还有著名的耐克（Nike）公 2015-01-11 20:26:19 人身上我们看到一位真正慈善家的美德。慈善不是在富有以后拿出自己的闲钱来沽名钓誉，更不是以此来为自己做软广告，慈善是在自己哪怕也很困难的时候都在帮助社会的一种善行。 2015-01-11 20:28:28 “这时期，整个学校的命运完全靠一个善良妇女的爱心来维系。” 2015-01-11 20:28:58 她的爱心，靠她坚韧不拔的毅力开创出一所改变世界的大学。 2015-01-11 20:34:55 帮助斯坦福大学解决这个问题的是它的一位教授弗里德里克·特尔曼，他后来被称为硅谷之父 2015-01-20 00:00:14 美国虽然在从科学技术向产品转化方面做得比其它国家好一点，但是仍然明显存在着工业界和学术界相脱节的现象，这不仅表现在大学研究的课题脱离实际，也表现在工业界在遇到问题时找不到答案，而能够紧密联系这两头的斯坦福大学的师生常常就起到了重要的桥梁作用。在 2015-01-22 00:16:46 美国有句话，“哈佛难进，麻省难出”。而斯坦福大学实际上是既难进又难出，它 2015-01-22 00:19:50 为什么斯坦福大学能培养出这么多优秀毕业生，尤其是工业界的领袖呢？这一方面是因为斯坦福守着硅谷有得天独厚的优越条件，另一方面和它的教育方式有关。 2015-01-22 00:21:11 教育的目的不是传授实用技能和进行职业训练，而是教授礼仪、修养和德行 2015-01-22 00:22:32 完全是按照洪堡的体制来的。遗憾的是又没有学到家，“忘了”在大学里建立研究生院，以至于研究生教育至今落后。 2015-01-22 11:16:52 年后，它的学生安德鲁·怀特（Andrew White）也把康奈尔从一个小的乡村学院办成了一所世界一流的研究型大学。（吉尔曼后来又担任了卡耐基学院的校长，奠定了今天卡耐基梅隆大学在工科世界一流的地位。） 2015-01-22 11:18:32 凡事有利必有弊，一个教授的时间是有限，搞研究的时间多了，办公司的时间多了，在本科生教学上投入的时间就少。这就是斯坦福大学本科教学水平赶不上普林斯顿，也比不上它的邻居伯克利的原因。 2015-01-22 11:21:41 纽曼有点像围棋里的求道派，在他看来，大学是传播大行之道（Universal Knowledge）而不是雕虫小技的地方 2015-01-22 11:22:01 当许多聪明、求知欲强、具有同情心而又目光敏锐的年轻人聚到一起，即使没有人教，他们也能互相学习。他们互相交流，了解到新的思想和看法、看到新鲜事物并且掌握独到的行为判断力。” 2015-01-22 11:25:41 纽曼的教育方法要求受教育的人有很高的自觉性。 2015-01-22 11:26:00 纽曼教育方法成功的第二个关键因素是大学学生和文化的多样性 2015-01-22 11:29:42 拉里·佩奇在 Google 成功后回到斯坦福大学介绍他成功的经验时强调的一点是，创业者要成为全才（用他的原话讲，Be an expert in all aspects.）从培养全才来讲，斯坦福大学无出其右。 2015-01-22 11:33:36 可以想象如果佩奇和布林不是斯坦福的研究生而是什么其它学校的，他们很难有机会直接向一位工业界领袖推销自己的发明。大家可以试想一下，在中国，一位普通的清华大学或者北京大学的研究生有没有可能通过学校直接见到华为的创始人任正非，斯坦福能做到这件事是它了不起的地方。 2015-01-22 11:35:35 妨碍一个创业者成为业界领袖的原因有很多。其中有两条不得不注意，第一是好高骛远：关于这一条我们在前面已经多次提及，就不再赘述了。第二就是小富即安：很多人办公司都本着捞一把的想法，而不是做一番事业，这些人归根结底是创业的境界不够高。而这 2015-01-22 11:43:33 都是学生们为了完成学业，挖空心思想出来的项目，和太阳工作站、思科路由器、雅虎网站和 Google 搜索引擎这些源于创业者的科研实践的项目完全不同。 2015-01-22 11:43:41 环境是可以影响人的。 2015-01-22 11:45:32 世界很多国家都在学硅谷的经验，办起了自己的科技园。尽管有些地区自称自己是“xx 的硅谷”，并且带动了地区性信息产业的发展，提供了不少就业机会，但是并没有孕育出像思科和雅虎这样具有开创性的公司。这里面的原因有很多，其中一个是缺乏一所像斯坦福大学这样的新的公司乃至新的产业的孵化器。 结束语 2015-01-22 11:52:29 首先，我们这个世界，这个社会是个整体，任何一方的损失实际上也是我们自己的损失。第二，华尔街对世界经济和生活的重要性比原本我们想象的重得多。它们是左右科技公司的金融力量 2015-01-22 11:54:18 在直到二十世纪初的很长时间里，美国没有中央银行！而在这一百多年里，美国的私有银行得到了长足的发展，它们奠定了今天美国银行业的基础。 2015-01-22 11:57:19 十九世纪后半叶，美国因为种族矛盾尖锐，后来又爆发了内战，罗斯柴尔德家族对美国不看好，撤走了在美国的大部分业务，失去了追随美国发展的大好时机。（我常常和别人讲，错过现在中国发展的快车，就像一百五十年前错过美国发展一样可惜。 2015-01-22 11:59:23 言归正传，由于美国银行业的基础是私有银行，抵抗金融危机的能力就很有限， 2015-01-22 12:00:08 这时，由著名银行家摩根发起，联合了各大银行，在总统威尔逊的支持下，美国建立了联邦储备银行系统（Federal Reserve System），简称美联储。 2015-01-22 12:01:27 美联储虽然名字叫储备银行，但是它并没有什么储备，它的职责基本上是 2015-01-22 12:01:36 发行美元和制定利率。而美国整个经济活动，包括科技公司的商业活动依然靠私有银行来维持运转。 2015-01-22 12:49:45 在美国著名的商业银行有花旗银行（Citi Group）、美洲银行（Bank of America）、J.P.摩根银行（J.P. Morgan，以前叫大通曼哈顿银行），这 2015-01-22 12:55:02 投资公司，虽然他们又称投资银行（Investment Bank），但是直到 2008 年 10 月，它们都不是真正意义上的银行，因为他们既不能接受存款，也不能向联邦储备银行借钱，它们是替 2015-01-22 12:55:09 别人买卖有价证券、期货、不动产和任何有价值的商品。不买卖股票的人对这一类公司就不大熟悉了。这些公司中最著名的是高盛（Goldman Sachs 2015-01-22 12:59:49 华尔街传统的大投资银行有三家，高盛、摩根斯坦利和美林。我个人认为，美林的水平和前两个差出至少一个数量级。如果 2015-01-22 13:01:52 盛的主要业务是替别人做交易和承包公司的上市（underwriter 2015-01-22 13:18:10 科技公司中，大家最害怕的莫过于微软。而微软至今也不过挤垮了一家几千人的网景公司，打压了太阳公司和苹果公司。高盛在最近的半年里，先在石油上整垮了一批石油大鳄，继而连俄罗斯这个联合国常任理事国都打压下去了，接着又在这个月的金融危机中整垮了它一百年来的两个的竞争对手雷曼和美林。 2015-01-22 13:18:26 世界上唯一能和高盛有一比的就是摩根斯坦利 2015-01-22 13:18:54 摩根斯坦利和美国的大银行 J.P.摩根原来是一家，都是又美国二十世纪的大金融家 J.P.摩根创立 2015-01-22 13:19:16 1935 年，J.P.摩根的儿子亨利.摩根和高管哈罗德.斯坦利（Harold Stanley），带领一部分的 J.P.摩根银行的人，成立的摩根斯坦利公司。 2015-01-22 13:21:50 值得一提的是，摩根斯坦利是银行业中计算机化的先驱。早在 1962 年，它就通过计算机来分析股市并且建立了很多用于金融的数学模型（Quantitative Financial Analysis Model），并且获得了很大的成功。 2015-01-22 13:22:40 一个科技公司的成功从根本上讲要看它是否代表了技术发展的潮流，要看它的运营等自身的因素。但是，华尔街对它的影响也是难以低估的 2015-01-22 13:24:08 风投公司要收回投资，科技公司的创始人和早期员工要得到创业的回报，只有两条路可走，第一是被收购，比如 YouTube 被 Google 收购，Skype 被 Ebay 收购。这种做法来钱快，操作简单，但是收益相对低一些，走这条路的公司常常是有很好的技术，或者很多用户，但是自己难以盈利的，YouTube 和 Skype 都属于这一种。第二是将自己的一部分股票到交易市场 2015-01-22 13:24:27 上公开出售（Initial Public Offer，简称 IPO），俗称上市。多数能够很好盈利的公司基本上都走了这条路，因为公开出售股票不仅可以让投资人收回回报，还可以为企业的发展筹措资金。 2015-01-22 13:25:21 承包商从上市中可以得到两笔收入，第一是佣金，通常是包销股票总金额，即融资额的百分之七，第二是今后以上市价继续购买该公司一定股份的权利（大致等同于期权）。 2015-01-22 13:25:43 第一，在上市的一瞬间百度总的市值值多少钱 2015-01-22 13:26:37 作价太低，它们将拿不到什么佣金。佣金是承包商旱涝保收的钱， 2015-01-22 13:28:03 。而众所周知，大客户一般比小客户更倾向于长期投资而不是短线炒股套利。因此百度上市后，市场上几乎不可能有股票流通，在相当长时间里，股价肯定看涨。根 2015-01-22 13:30:32 第二，上市公司融资多少。 2015-01-22 13:32:54 在前一种情况下，企业得到了充分的发展资金，但是原有股东的利益损失很大。在后一种情况下，原有股东过于吝啬，使得公司错过了很好的融资机会。 2015-01-22 13:33:14 融资过多和过少都是有危害的。过度的融资不仅导致原有股东的利益被压缩，而且由于在短时间里流入市场的股票太多，股价很难稳定。融资过少的危害也很明显，很多公司就是因为融资不足而在经济进入低谷时无资金摆脱困境而关门。 2015-01-22 13:33:32 一般来讲，融资的比例应当是公司市值的 10% 到 25%。 2015-01-22 13:33:55 第三，第一个和第二个问题确定后，还剩的是一些细节问题 2015-01-22 13:34:01 了，主要是百度付给承包商的佣金和今后的期权。一般来讲，著名的承包商要的条件也高。 2015-01-22 13:36:36 投资银行和基金公司对科技公司最大的支持就是直接购入该公司的股票。 2015-01-22 13:37:10 华尔街公司对科技公司的追捧还可以通过提高对科技公司的评级等不需成本的手段进行。由 2015-01-22 13:38:24 华尔街会为每个科技公司订出销售额和盈利的预期。如果一个科技公司能够在连续多个季度里超过盈利预期，华尔街就会拼命提升该公司的股价 2015-01-22 13:41:50 根据美国证监会的规定，抵押一定现金“借”股票卖空是允许的，但是卖出的股票一定要在三天内提供给购买该股票的人。既 2015-01-22 13:43:10 为了不断达到华尔街的预期，几乎所有市场占有率超过一半的大跨国公司都不得不努力寻找新的成长点。这实际上是软件生意做得相当好的微软一定要进入互联网市场的根本原因 2015-01-22 13:46:31 要想不受华尔街的影响，唯一的办法就是不上市。这就是 Google 在盈利很久以后迟迟不肯上市的原因。一 2015-01-22 13:47:46 华尔街长期打压，这时，私募基金会出钱将该公司流通的股份全部收回将它变成私有公司，经过包装后从新上市，这时新的公司常常就会从华尔街的弃儿变为宠儿。著名的计算机硬盘公司 Seagate 就经历过此过 2015-01-22 14:01:00 微软股价下跌的原因是华尔街不看好微软收购雅虎以后的前景。 2015-01-22 14:03:53 对于华尔街看好的收购，消息一传出，出资收购的一方股价会猛涨。 2015-01-22 14:04:44 金融业在整个经济活动中起着血液的作用。健康的金融环境和秩序可以帮助科技公司的成长 2015-01-22 14:05:24 事实上，在美国一个上市公司的首席财务官它的首要任务并不是替公司管账，而是和华尔街沟通。他 2015-01-22 14:05:33 应该能用财务的语言，将他的公司的长远规划向华尔街讲清楚并树立华尔街对他的公司的信心。 结束语 2015-01-22 16:48:42 Google 公司从一开始，就以一个挑战者的身份出现在人们的视野中。它不仅在技术上和商业上挑战比自己更大更强的公司，而且在理念上挑战传统。 2015-01-22 16:51:32 Google 其实是被美国《公司法》逼得不得不上市的。 2015-01-23 00:53:49 Google在IPO 时做了三件惊人的事。​ 第一件事就是采用拍卖的方式决定IPO 的股价 2015-01-23 00:55:29 Google 上市的第二个特点就是将一次融资拆成三次。一 2015-01-23 00:58:17 Google 上市时做的第三件非同寻常的事就是学习巴菲特的伯克希尔一哈撒韦公司，将Google 的股票分成了投票权完全不同的两种 2015-01-23 00:59:03 发现其中成功的一条就是公司内部的人要有绝对的发言权(投票权) 。 2015-01-23 01:00:28 其结果是不管一个投资人从市场上购买多少Google 的股票，只要它的创始人持有10% 的股票就可以拥有绝对多数的投票权。这样，华尔街很难直接干涉Google 的发展。两 2015-01-23 01:07:16 西尔弗斯坦可以称得上是一位计算机奇才，他几乎一个人写出了Google 搜索引擎的第一个商业版本。 2015-01-23 01:10:31 佩奇和布林是心比天高的人，根本不是那种赚一笔快钱就跑的人，也不是那种赚快钱的人可以理解的，用中国的古话讲就是”燕雀焉知鸿鸽之志” 2015-01-23 01:12:37 。”Google 一开始也不知道怎么挣钱，后来搜索广告做成功了，才找到商业模式” 。我不能说这个观点是完全错误的但是它非常片面，说明讲这话的人不了解Google 的创始人。 2015-01-23 08:31:21 有了正确的方向，挣钱只是早晚的事 2015-01-23 08:36:06 Google 最神奇的Google Earth 其实也是从第三方手里买来的数据， Google 做了一个大家容易使用的界面而已。 2015-01-23 08:37:39 因此， Google 的产品一直是针对广大用户，既非像IBM 那样针对企业，又非像苹果那样针对精英。 2015-01-23 08:40:27 Google 在商业上成功的另一个原因就是将中间环节减少到最少。 2015-01-23 08:42:23 Google 一直宣传团队精神，但是Google 从不虚伪，所以并不要求个人无条件服从团队，因此在Google 内部换来换去很常见。而早期的Google则更赞赏个人英雄主义，而且往往发扬个人英雄主义。 2015-01-23 08:46:29 外界对于Google 的成功一般归结于领先的技术，这的确是主要原因。但是Google 的营销能力也是同行业中数一数二的。 2015-01-23 08:47:22 Google 早期的员工都是各自领域的佼佼者，每一个人的故事都能写一本书。正是靠这一个个精英， Google 才能创造历史。 2015-01-23 08:48:41 你认为如何可以改进Google” ，或者， “你来了以后将如何使我们变得更好” 。 2015-01-23 08:50:15 Google 鼓励每一个人成为英雄，它希望每一个人都做出对公司有很大正面影响的贡献， 而不只是”没有功劳也有苦劳”的工作，并且它给予成为英雄的人很高的奖赏。 2015-01-23 08:55:07 他们确定了Google 产品设计的指导思想必须突出搜索，淡化浏览。因为如果强调了浏览，必然把用户推到门户网站去 2015-01-23 08:59:23 在Google 上市前很长的时间里，科德斯坦尼的信息一直是大家的精神支柱 2015-01-23 09:00:02 Google 像一个大家庭，大家虽然工作很辛苦，收入不高，但是过得开心。 2015-01-23 09:01:01 什么是不作恶，用中国的古话讲就是要做正人君子。当然，不作恶反映在商业上，就是要公平地和对手竞争，而不采用非正常的手段。 2015-01-23 09:01:49 所以， Google宁可让雅虎将lnktomi 买走并成为了自己在搜索领域的对手，也没有做损人利己的事。Google 这种君子之风，日后得到了巨大的回报。几 2015-01-23 09:02:44 不作恶还表现在做事的客观和公正。这首先反映在Google 对待搜索结果的排名上 2015-01-23 09:02:58 搜索结果的排名关键取决于两个因素，网页和查询的相关性及网页本身的质量 2015-01-23 09:04:42 因此， Google 宁可有些查询给出不是很相关的搜索结果，也拒绝人为调整 2015-01-23 09:05:10 但是Google 坚持搜索排名不出售的政策。 2015-01-23 09:06:26 在物欲横流的今天，为什么Google 能够洁身自好?因为它的创始人、它的执行官和大部分员工都懂得，要想长期发展，就必须在整个工业界、在大众中树立良好的形象并赢得大家的信赖。 2015-01-23 09:07:29 但是，芒格依然补偿了那些撤资人的损失!这种风格在尔虞我诈的华尔街简直是异类。 2015-01-23 09:10:10 Google 从来不在媒体上替自己做广告，但是，和雅虎的合同就是一个大广告。 2015-01-23 09:38:56 遗憾的是，雅虎用自己的短处去比别人的长处，就不得不接受Google 指定的游戏规则-一技术决定成败。在这种情况下的竞争结果其实已经没有悬念了。 2015-01-23 09:51:51 第一，根据Google 一贯”快速向前跑，不要看两边”的风格，它的核心技术和运营部门要赶在微软还没有推出搜索引擎和搜索广告系统以前拉开和微软的差距， 2015-01-23 09:52:12 第二，和微软竞争人才 2015-01-23 09:53:20 第三，未雨绸缪，联合其他公司来抵消微软在操作系统中捆绑搜索对Google 带来的不利影响。 2015-01-23 09:56:28 但是，它新业务的扩展却也困难重重。在网上支付方面它的Checkout 远远落后于eBay 的PayPal ，它的Gtalk ( IM ) 大大落后于MSN 。它在社区平台上远远落后于Facebook 2015-01-23 10:02:13 Google 不仅喜欢招博士(和通过博士资格考试但尚未毕业的博士生) ,而且特别偏爱名牌大学和考试成绩好 2015-01-24 00:28:42 在Google 看来一个理想的员工是你交代给他一件事，不用操心，他就给你完成了。更理想的员工是你都不用交代他任何事，他每个季度自动给你完成很多有益的工作。 2015-01-24 00:36:03 这里面一个关键性人物是前面提到的副总裁霍尔斯。从2003 年起，大学教授出身的霍尔斯全心全意地投入到公司的业务运营管理和基础架构的建设中。他的贡献有三个方面:第一，在全球通过租用和收购已铺设的光缆，以及铺设新光缆，保证了Google 业务发展后网速不成为瓶颈。第二，抢在很多公司以前在全球布局，占据了建设数据中心的最佳点。第三，设计了节能高效的服务器机柜，大大降低了运营成本。 2015-01-24 00:37:37 很长时间以来，微软是Google 最主要的竞争对手，于是Google 提出了云计算的概念，希望今后整个产业界将越来越多的服务从PC 机客户端搬到网上，减少用户对微软的依赖。 2015-01-24 00:40:00 这里需要强调的是， 云计算的产业链一旦形成， 对现在信息产业的影响将是颠覆性的。每一次重大的技术变革都预示着产业格局的演变，也会促成主流企业的重新洗牌。Google 正在以此为契机，希望能够在下一次产业变革中领跑。 2015-01-24 00:44:12 李开复可以说是至今唯一一个和中国大学生贴近的跨国公司的执行官。几乎所有的跨国公司的高管，在中国普通大学生眼里，不过是报纸和回忆录中的符号，他们的生活和中国大学生的生活没有任何交集。而李开复则不同，他和大学生们的关系是亦师亦友，他的经历和言行激励了一代年轻学生。 2015-01-24 00:46:07 随着自由派总统奥巴马的当选和任职，美国和中国的蜜月期终于过去了。自由派人士占主导的Google总部对中国的互联网管制方式一直难于接受，这中间的矛盾全压在李开复身上。终于有一天，他不堪重负，选择了离开。 2015-01-24 08:39:57 中国人总爱引用19 世纪英国首相帕默斯顿( Palmerston )的话，没有永远的盟友，也没有永远的敌人，只有永远的利益( We have no eternal allies, and we have no perpetual enemies. Our interests are eternal and perpetual, and those interests it is our duty to follow ) 。但是大家的引用都不全，甚至有些断章取义，因为都忽视了最重要的最后一句话”而谋求那些利益是我们的职责所在” 。 2015-01-24 18:06:59 Google 学的是当年微软的做法，横着吃整个市场。它只关心最重要的操作系统部分，而把上下游全部交出去。比微软更绝的是， Google 的操作系统是免费的。 2015-01-24 18:13:44 在商业竞争中，进攻常常也是最好的防守。Google 从小到大一直贯彻这个原则。 2015-01-24 18:14:24 但是， Google 不是通过防范对手的办法来保护自己，而是主动将战线推到对方的领域。毫无疑问，电子邮件Email 服务是最容易拴住用户的 2015-01-24 18:30:52 Google 大事记1998 Google 成立。1999 美国最大的两家风险投资公司K PCB 和红杉资本同时投资Google . 这是这两家公司第一次同时投资一家Startup 。2000 雅虎采用Google 的搜索引擎。 2015-01-24 18:31:56 2001 Google 推出搜索广告系统Adwords ，并于当年第4 季度实现盈利; 同年，埃里克• 施密特成为Google 正式的CEO 。2002 美国在线采用Google 的搜索引擎和广告系统I Google 占到为全球搜索流量的70% 。2003 Google 第二个广告产品Adsense 上线。2004 Google 采用竟饱的方式上市; 同军Google 革命性的Gmail和Google Earth 产品上线。2005 Google 中国公司成立。2006 Google 在线支付产晶Checkout 上线，效果极差， 成为Google 第一款失败的主要产品;同年Google 收购YouTube。2007 Android 联盟成立。2008 第一款基于Android的手机由HTC出厂，但是销路一般；同年Google推出Chrome 浏览器。2009 受金融危机的影响. Google 第一次裁员.但是很快回到增长的轨迹; 同年随着摩托罗拉Droid 手机的上市，Android 手机操作系统获得巨大的成功。2010 Google 的手机操作系统Android 市场占奇量超过苹果的iPhone，浏览器Chrome也从微软手中夺得15% 的市场份额， 但是官在社交网络上一直输给Facebook 。2011 共同创始人佩奇撞蕾施密特成为Google 新CEO 。 19.3 戴尔的虚拟工厂 2015-01-24 18:55:08 在所有商业模式中，最理想的就是能像印钞机那样自动挣钱的模式。我们在这一章中介绍三个成功的模式，Google 的广告系统，Ebay 的电子商务系统和戴尔的微机直销系统。 2015-01-24 19:12:38 这个印钞机另一个奇妙的地方在于，它可以通过机器学习（Machine Learning）不断完善自己，“印出”越来越多的钞票。当 2015-01-24 19:21:18 一个传统的制造业需要通过产品设计、原料采购、仓储运输、加工制造、订单处理、批发经营和零售七个环节才能收回投资、获得利润。 2015-01-24 19:25:10 戴尔公司过人之处不在于其技术和市场能力，而在于它将传统的制造业的七个环节简化到两个，这是一个了不起的商业革命。正是靠着这个革命性的商业模式，戴尔才能从众多兼容机厂商中脱颖而出，成为全球主流的微机生产厂商。 20.4 是革命还是泡沫 2015-01-24 19:29:27 Google 再次证明了利用广告维持互联网运营并且提供免费服务的商业模式适合于互联 2015-01-24 19:34:17 词尾pedia 源于古希腊语的paideia ，意思是教育和文化。百科全书一词的英文为encyclopedia ，就是以pedia 做词尾。两个词合在一起就是基于Wiki 技术的百科全书。 2015-01-28 11:12:18 Facebook 以大学生和大学毕业生为主，而MySpace 则是中学生的天堂。 2015-01-28 11:12:27 Facebook 和MySpace 远不止是所谓的“社交网站”，而是从“社交网络”起步的一个平台 2015-01-28 11:12:43 。在此平台上，用户不但可以提供内容，而且可以提供服务。 2015-01-28 11:14:33 Facebook 完全不同，它只是为大众提供一个平台，用它前一任总裁帕克的话讲， 它们其实不需要知道用户想在Facebook 上做什么，只是让用户感到酷。至于在这个平台上用户需要什么他们自己去开发。 2015-01-28 11:16:44 作为一个互联网的公司也是一样，好的公司不需要提供具体的内容和服务，而是让用户自行解决。这是互联网2.0的精髓所在。 2015-01-28 11:34:59 第一，广告的效果。总的来讲，广告商们都不是傻子，他们讲究广告的投入产出比（ Return of lnvestment ，ROI），也就是每花一元广告费可以带来多少生意。 21.1 金融危机的成因 2015-01-28 11:41:27 金融危机的直接和表层的原因是“次贷（Subprime Loan） ”及与之相关的金融衍生物CDS ，而间接和深层的原因则是违反经济规律地只消费不创造，从而坐吃山空 2015-01-28 11:44:50 上世纪90 年代，克林顿担任总统期间，为了让穷人也能拥有住房， 美国发明了次级贷款 2015-01-28 11:45:23 当然，次级贷款的利率较高，因此有的银行明知有风险也愿意做。 2015-01-28 11:46:21 主席格林斯潘通过11次降息，剌激投资和经济增长，很快将美国经济带出低谷。当人们为格林斯潘神奇的控制经济的能力叹服时， 实际上他是用一个更大的房市泡沫解决了相对小得多的互联网泡沫的问题。 2015-01-28 11:47:20 购房者觉得自己买得起更贵的房子了。 2015-01-28 11:47:32 于是，没有房子的人开始买房子，有房子的人开始换更大的房子， 一个房市泡沫就开始形成 2015-01-28 11:49:12 其实，真正要了银行命的还不是次贷本身，而是它的衍生物Credit Default Swap（简称CDS）。 2015-01-28 11:53:33 就这样，金融公司就将这种担保业务打了包，以证券的形式一样在市场上交易，这就是CDS。到最后，上述的F公司可能又将CDS实回给A银行。 2015-01-28 11:55:58 拥有B一个亿的CDS证券（即B欠A 一个亿） ， B拥有C一个亿的， C拥有A一个亿的。看上去有三个亿的市场规模，当CDS 变得一钱不值时，看上去三家都有一个亿的烂账，其实只要三家坐下来谈一谈，每家的烂账就少掉一个亿 2015-01-28 11:59:25 也就是说，从克林顿时代开始的美国所请经济繁荣是建立在寅吃卵粮的基础上的，或者说是过度投资堆起来的，而不是靠提高竞争力带来的 2015-01-28 12:00:17 使得资本的拥有者（不一定是资本家，每一个有存款的人都在此列）大量撤回投资，以现金的形式保留财富。这样，我们社会的再生产和发展就变得难以维持，这也就是所谓的流通不足 2015-01-28 12:01:04 恢复经济靠什么，短期靠基础建设， 因为它在创造工作机会上见效快。长期靠科技产业（IT），因此每一次经济危机，就导致我们对科技的依赖越来越强。而所有的科技公司都必须经历这次金融危机的洗礼。 22.4 对IT 产业链的颠覆 2015-01-30 08:36:26 由于在微软的黄金时代里，世界上几平没有一家公司在客户端软件中能打赢微软的，所以埃利森干脆放弃在客户端和微软的竞争，提出一种新的商业模式：Network Computer。 试图干脆将用户对客户端的需求降到最少。这种对微软釜底抽薪的做法在战略上确实是一步非常好的棋， 2015-01-30 08:42:54 当时这三家对云计算的理解完全不同。IBM 是为了卖设备，Google 是因为有大量用户，希望将用户的应用都搬到网上，而亚马逊则是希望出售计算能力给各个商家和网站 2015-01-30 08:51:39 IBM 服务的对象依然是企业级用户，它的商业模式是卖云计算的服务器。这是IBM 对云计算的理解。它不具有自己对外使用的数据中心， 因此至少目前无法提供对外的服务。 2015-01-30 08:53:02 这样，任何一个想通过互联网提供服务（包括电子商务） 的公司和个人都不需要自己建网站，而只要租用亚马逊的计算资源即可。 2015-01-30 08:58:48 和IBM 与亚马逊都不同。 Google 强调的是对用户的服务 2015-01-30 08:58:55 总的来讲，这三家各有各的特点和市场，基本上是互补关系而不是竞争关系。把他们的想法合起来，就可以得到云计算的本质了。 2015-01-30 16:56:23 GFS 是Google 文件系统（ Google File System ）的缩写 2015-01-30 16:57:35 GFS的目标是在分布式的多台机器上存储海量数据，同时对于它的用户来讲，所有的操作都和在一台计算机上操作一个小文件一样简单。 2015-01-30 16:58:00 Google 于是推出了第二代云计算文件系统CFS ，规模是GFS 的1000倍 2015-01-30 16:59:55 考虑到在实际应用中大量的数据都是结构化的（类似于数据库系统的） ，Google 提出和实现了针对这些应用的大型结构化数据的BigTable 系统。 2015-01-30 17:00:16 第一个是被称为MapReduce 的工具。它将一个巨大型的任务分解为无数小任务，分派到不同服务器中完成，然后再把每一台服务器上完成的小任务合并起来，达到最终完成大任务的目的。 2015-02-05 22:51:23 其次，随着云的普及，新的产业生态链将形成。基于互联网开发的公共平台将变得越来越重要，它将从某种程度上替代原来操作系统的作用， 23.4 关注亚太地区 2015-02-05 23:18:08 而当时，另一种更成功的商业模式，是所谓的WinTel体系，即微软的Windows 操作系统加上英特尔的处理器，其他所有PC 的软硬件厂商向Windows 和Intel 靠拢 2015-02-05 23:20:07 虽然目前在手机上最容易挣钱的应用还是搜索，而且手机搜索的商业转换率甚至好于传统互联网上的搜索，但是，从长远看，基于手机的支付和社区（包括游戏）商业前景非常乐观。因为Google 在这两个领域并不很领先。 2015-02-05 23:21:17 电子支付无非是要确认个人的身份。手机是一个人身份最好的验证手段，它具有便携、通信方便的好处，并且可以根据安全需求加人多重保护，包括密码和生物特征（指纹、面孔和虹膜） 。在商店里，手机支付可以简单到把手机往收银机上一放就能完成转账。 2015-02-05 23:22:56 Google 更多地是一个科技公司，而百度仅仅是一个互联网公司，就如同当年风光一时的雅虎是个技术竞争力不很强的互联网公司一样。 2015-02-05 23:23:21 百度难以成为国际化公司的原因是它在所有的非中国大陆市场上的努力都是失败的。相比之下阿里巴巴在海外的扩展至今是成功的。 2015-02-05 23:24:23 事实上是，中同非常糟糕的批发和零售商业环境，要求必须出现一家阿里巴巴这样让 商业变得容易的公司。 2015-02-05 23:25:22 中国自己制造的东西在自己家门口居然比远渡重洋之后要贵很多，这实在是有些荒谬，而导致这种荒谬现实的原因是中国的流通环节太多、服务也太恶劣。一个集装箱从广东运到北京的费用，远比它运到太平洋对岸的洛杉矶要高，因为中国的公路铁路收费太贵，而在美国从洛杉矶到旧金山五百公里的高速公路上是不需要交一分钱的过路费的。一 2015-02-05 23:26:37 如果退回20 年，中国很可能要走美同建立超级连锁店的做法，用几十年时间建立起自己的沃尔玛和建材城Home Depot。但是，由于互联网和电子商务的出现，中国有可能跳过这一步，直接建立在线电子商城。阿里巴巴就是顺应了这个潮流，脱颖而出。 多看笔记 来自多看阅读 for Kindle]]></content>
      <categories>
        <category>读书摘录</category>
      </categories>
      <tags>
        <tag>多看</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test math]]></title>
    <url>%2F2017%2F11%2F02%2Ftest-math%2F</url>
    <content type="text"><![CDATA[\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[238. Product of Array Except Self]]></title>
    <url>%2F2017%2F11%2F01%2F238-Product-of-Array-Except-Self%2F</url>
    <content type="text"><![CDATA[Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Solve it without division and in O(n). For example, given [1,2,3,4], return [24,12,8,6]. Follow up:Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.) 主要就是预处理。把数组预先正序和逆序都累乘一遍，这样针对某个nums[i]，只需要将其前面的正序积和其后面的逆序积相乘就可以得到答案了。 12345678910111213141516171819202122232425262728293031//// Created by chaopengz on 2017/11/1.//#include "head.h"class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt; &amp;nums) &#123; int len = (int) nums.size(); vector&lt;int&gt; ans; vector&lt;int&gt; fromBegin; vector&lt;int&gt; fromEnd; int sumBegin = 1, sumEnd = 1; fromBegin.push_back(1); fromEnd.push_back(1); for (int i = 0; i &lt; len; ++i) &#123; sumBegin *= nums[i]; sumEnd *= nums[len - 1 - i]; fromBegin.push_back(sumBegin); fromEnd.push_back(sumEnd); &#125; for (int j = 0; j &lt; len; ++j) &#123; ans.push_back(fromBegin[j] * fromEnd[len - j - 1]); &#125; return ans; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[141. Linked List Cycle]]></title>
    <url>%2F2017%2F10%2F24%2F141-Linked-List-Cycle%2F</url>
    <content type="text"><![CDATA[Given a linked list, determine if it has a cycle in it. Follow up:Can you solve it without using extra space? 题意：判断一个链表是否带环。 这是一道关于链表很经典的题目，解法其实跟跑操场（操场就是个环）原理很类似：A,B从同一起点开始一起跑，A跑得慢，B跑得快，那么B一定会在某个时刻跟A相遇（B比A跑快了一圈了）。 但是万一没有环呢？因为B跑得快，所以只要B还没到终点，A就肯定还没到终点。所以只需要判断跑得快得指针非空就行了。 一开始的代码就写错了，既判断了A又判断了B。 123456789101112131415161718class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if (!head) return false; ListNode *p1 = head;//跑得慢 ListNode *p2 = head;//跑得快 while (p1-&gt;next &amp;&amp; p2-&gt;next-&gt;next)//这里p1错了，不需要管跑得慢的 &#123; p1 = p1-&gt;next; p2 = p2-&gt;next-&gt;next; if (p1 == p2)//类似跑操场，跑得快得肯定会追上跑得慢的，快一圈相遇 return true; &#125; return false; &#125;&#125;; 正确的代码如下： 123456789101112131415161718192021222324252627struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(nullptr) &#123;&#125;&#125;;class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if (!head) return false; ListNode *p1 = head;//跑得慢 ListNode *p2 = head;//跑得快 while (p2-&gt;next &amp;&amp; p2-&gt;next-&gt;next)//只需要关注跑得快得到不到终点就行 &#123; p1 = p1-&gt;next; p2 = p2-&gt;next-&gt;next; if (p1 == p2)//类似跑操场，跑得快得肯定会追上跑得慢的，快一圈相遇 return true; &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LinkList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包问题小结]]></title>
    <url>%2F2017%2F10%2F16%2F%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天在刷到LeetCode 039. Combination Sum这道题时，一看就是完全背包的问题，所以就趁机参考《挑战程序设计竞赛》把背包问题进行一个小结。 01背包 题意：有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。 之所以称这类问题为01背包问题，就在于每件物体只有两种状态， 放 不放 所以理论上只要枚举所有可能性就能得出最后答案，但是复杂度高达：2^n次方，这样显然是不行的。 所以，只能寻求复杂更低的做法。仔细观察，这类问题其实包含主重叠的子问题 你判断第N个物体的抉择时的和你前面N-1个物体是怎么选的有很大的关系。所以就可以用动态规划的思想来解决。 而用动态规划，最主要就是想清楚两件事情： 状态的定义 状态的转移 转移的转移不难想，肯定是根据第i个物体选或不选来规定转移方程的。 但是在状态的定义上，有时会因人而异。 我个人比较喜欢如下定义。 1dp[i][j] = 从前i个物品中选出不超过j的价值之和 这样定义后状态转移方程便成了 1dp[i][j] = max&#123;dp[i-1][j]/*不选*/, dp[i-1][j-c[i]]+w[i] /*选*/&#125; 代码实现： 123456void solve()&#123; for(int i = 0 ; i &lt; N; i++) for(int j = 0 ; j &lt; V; j++) dp[i][j] = max(dp[i-1][j],dp[i-1][j-c[i]]+w[i])&#125; 其实就是一个填表的过程：每一行的某个数都是由上一行根据一定的规则推算出来的。 在崔天翼的《背包九讲》中，还进一步压缩了空间复杂度。因为dp(i)(j)中的j要么由上一行的j推出，要么由上一行的j-c[i]推出。所以只需要保证，j遍历的时候小的部分保留着上次计算的结果就行，那么就只需把j倒序便ok了。 123for(int i = 0 ; i &lt; N ; i++) for(int j = V, j &gt; 0 ; j--) dp[j] = max(dp[j],dp[j-c[i]]+w[i]) 完全背包完全背包与01背包相比，区别就是每件物体选的个数不设上限，可以取无限次。刚开始以为还以为有多难，其实空间压缩到一维后，与01背包的代码异常类似： 123for(int i = 0 ; i &lt; N ; i++) for(int j = 0, j &lt; V ; j++) dp[j] = max(dp[j],dp[j-c[i]]+w[i]) 是这么理解的： 你会发现，这个伪代码与P01的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么P01中要按照v=V..0的逆序来循环。这是因为要保证第i次循环中的状态f[i][v]是由状态f[i-1][v-c[i]]递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果f[i-1][v-c[i]]。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][v-c[i]]，所以就可以并且必须采用v=0..V的顺序循环。这就是这个简单的程序为何成立的道理。 崔真的是天才，从二维压缩到了一维，而且能够使到01背包和完全背包在解题形式上如此高度统一。 Reference： http://love-oriented.com/pack/ （背包问题九讲） 《挑战程序设计竞赛》（第二版）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[33. Search in Rotated Sorted Array]]></title>
    <url>%2F2017%2F10%2F16%2F33-Search-in-Rotated-Sorted-Array%2F</url>
    <content type="text"><![CDATA[Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. 错误的二分查找 123456789101112131415161718int binarySearch(vector&lt;int&gt; v, int begin, int end, int target)&#123; int mid = (begin + end) / 2; while (begin &lt; end) &#123; if (v[mid] == target) return mid; else if (v[mid] &gt; target) &#123; end = mid; &#125; else &#123; begin = mid; &#125; mid = (begin + end) / 2; &#125; return -1;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123;public: int binarySearch(vector&lt;int&gt; &amp;v, int begin, int end, int target) &#123; int mid = (begin + end) / 2; while (begin &lt;= end) &#123; if (v[mid] == target) return mid; else if (v[mid] &gt; target) &#123; end = mid - 1; &#125; else &#123; begin = mid + 1; &#125; mid = (begin + end) / 2; &#125; return -1; &#125; int search(vector&lt;int&gt; &amp;nums, int target) &#123; if (!nums.size()) return -1; int i = 0, j = nums.size() - 1; int mid = (i + j) / 2; if (nums[i] &lt; nums[j]) i = j; else &#123; int mid = (i + j) / 2; while (i &lt; j) &#123; if (nums[i] &lt; nums[mid]) i = mid; else j = mid; mid = (i + j) / 2; &#125; &#125; //now i the max value index if (i == nums.size() - 1) &#123; return binarySearch(nums, 0, nums.size() - 1, target); &#125; else &#123; if (target &gt;= nums[0]) return binarySearch(nums, 0, i, target); else &#123; return binarySearch(nums, i + 1, nums.size() - 1, target); &#125; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23. Merge k Sorted Lists]]></title>
    <url>%2F2017%2F10%2F16%2F23-Merge-k-Sorted-Lists%2F</url>
    <content type="text"><![CDATA[Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 题意表述异常简练：合并多个有序链表 虽然题目不长，但是这道在LeetCode上却是被标记为hard的题目。 自己在做这道题的时候，受两个有序链表合并题目，用两个指针不断比较，逐步前进的影响，所以开始想用多个指针，即建一个vector 来存储跟踪每一行即将被添加的数的所有指针。 但是这样有两个问题： 每次指针所指数被添加到总列表后需要将指针往前挪一位，不如vector下标的自增方便 循坏的结束 需要所有指针都指到最后，即都为NULL，两个还好， 多个就不好判断了 。转化成vector就好判断多了： 在每一行的最后加入一个最大的数INF，这样这个数永远不会被加到总列表中 统计原来的多个列表总共有多少个节点，即allNodes 这样循环allNodes次之后必能将所有的节点加入到总列表中了 具体实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//// Created by chaopengz on 2017/10/13.//#include "head.h"/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(nullptr) &#123;&#125;&#125;;class Solution &#123;public: ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) &#123; int INF = 2147483647; int Min; vector&lt;vector&lt;int&gt;&gt; vv; int len = lists.size(); ListNode *p; int allNodes = 0; //将链表转为二维vector for (int i = 0; i &lt; len; ++i) &#123; vector&lt;int&gt; v; p = lists[i]; while (p) &#123; v.push_back(p-&gt;val); p = p-&gt;next; &#125; v.push_back(INF); vv.push_back(v); allNodes += (v.size() - 1); &#125; //每一行即将被添加的数的索引 vector&lt;int&gt; index; //都从0，即链表头起第一个数开始 for (int j = 0; j &lt; len; ++j) &#123; index.push_back(0); &#125; int recoderIndex; ListNode *res = nullptr, *pre = nullptr; ListNode *pNode; for (int k = 0; k &lt; allNodes; ++k) &#123; Min = INF; for (int i = 0; i &lt; len; ++i) &#123; //找出最小的值 if (vv[i][index[i]] &lt; Min) &#123; Min = vv[i][index[i]]; //记录最小值所在的行 recoderIndex = i; &#125; &#125; pNode = new ListNode(Min); index[recoderIndex]++; if (res) &#123; pre-&gt;next = pNode; pre = pNode; &#125; else &#123; res = pNode; pre = res; &#125; &#125; return res; &#125;&#125;; 看了Discussion后，发现大佬的解法更为简单，即采取分而治之（Divide and Conquer）的思想。 两个有序链表不是很简单吗？那么多个有序的列表难道不是不断的两两合并，最后合到只剩下一个为止？ 123456789101112131415161718192021222324252627282930ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) &#123; if(lists.empty())&#123; return nullptr; &#125; while(lists.size() &gt; 1)&#123; //利用队列的思想，把第一个和第二个合并，然后新的列表加入到最后 lists.push_back(mergeTwoLists(lists[0], lists[1])); //丢弃最前面两个已经被合并好了的列表 lists.erase(lists.begin()); lists.erase(lists.begin()); &#125; return lists.front();&#125;//合并两个有序链表，递归解法，更加简洁易懂ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; if(l1 == nullptr)&#123; return l2; &#125; if(l2 == nullptr)&#123; return l1; &#125; if(l1-&gt;val &lt;= l2-&gt;val)&#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else&#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[22. Generate Parentheses]]></title>
    <url>%2F2017%2F10%2F16%2F22-Generate-Parentheses%2F</url>
    <content type="text"><![CDATA[Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: 12345678&gt; [&gt; &quot;((()))&quot;,&gt; &quot;(()())&quot;,&gt; &quot;(())()&quot;,&gt; &quot;()(())&quot;,&gt; &quot;()()()&quot;&gt; ]&gt; 12345678910111213141516171819202122232425//// Created by chaopengz on 2017/10/10.//#include "head.h"class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; res; add(res,"",n,0); return res; &#125; void add(vector&lt;string&gt; &amp;v,string s,int l,int r) &#123; if (!l &amp;&amp; !r) &#123; v.push_back(s); return; &#125; //加入左括号 if(l) add(v,s+"(",l-1,r+1); //加入右括号 if(r) add(v,s+")",l,r-1); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19. Remove Nth Node From End of List]]></title>
    <url>%2F2017%2F10%2F16%2F19-Remove-Nth-Node-From-End-of-List%2F</url>
    <content type="text"><![CDATA[Given a linked list, remove the nth node from the end of list and return its head. For example, 1234&gt; Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.&gt;&gt; After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.&gt; &gt; Note:Given n will always be valid.Try to do this in one pass. 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode *p1,*p2,*pre; p1=head; p2=head; pre=head; for(int i = 0; i &lt; n-1 ;i++) &#123; p1 = p1-&gt;next; &#125; while(p1-&gt;next!= nullptr) &#123; p1 = p1-&gt;next; pre = p2; p2 = p2-&gt;next; &#125; if (p2 == head) &#123; head = head-&gt;next; &#125; pre-&gt;next = p2-&gt;next; return head; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15. 3Sum]]></title>
    <url>%2F2017%2F10%2F16%2F15-3Sum%2F</url>
    <content type="text"><![CDATA[Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. 12345678910&gt; &gt; For example, given array S = [-1, 0, 1, 2, -1, -4],&gt; &gt;&gt; &gt; A solution set is:&gt; &gt; [&gt; &gt; [-1, 0, 1],&gt; &gt; [-1, -1, 2]&gt; &gt; ]&gt; &gt;&gt;&gt; 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); sort(nums.begin(), nums.end()); int findNum; vector&lt;vector&lt;int&gt;&gt;::iterator iter; vector&lt;vector&lt;int&gt;&gt; res; for (int i = 0; i &lt; len - 2; ++i) &#123; if (nums[i] &gt; 0) return res; for (int j = i + 1; j &lt; len - 1; ++j) &#123; findNum = 0 - nums[i] - nums[j]; if (findNum &lt; 0) break; if (binary_search(nums.begin() + j + 1, nums.end(), findNum)) &#123; vector&lt;int&gt; v; v.push_back(nums[i]); v.push_back(nums[j]); v.push_back(findNum); iter = std::find(res.begin(), res.end(), v); if (iter == res.end()) res.push_back(v); &#125; &#125; &#125; return res; &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//// Created by chaopengz on 2017/9/27.//#include "head.h"class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt; &amp;nums) &#123; int len = nums.size(); int j, k, sum; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; len - 2; ++i) &#123; if (i == 0 || nums[i] != nums[i - 1])//a = nums[i]取值不重复 &#123; j = i + 1; k = len - 1; sum = 0 - nums[i]; while (j &lt; k) &#123; if (nums[j] + nums[k] == sum) &#123; vector&lt;int&gt; v; v.push_back(nums[i]); v.push_back(nums[j++]); v.push_back(nums[k--]); res.push_back(v); while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) j++; while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) k--; &#125; else if (nums[j] + nums[k] &gt; sum) &#123; k--; &#125; else &#123; j++; &#125; &#125; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11. Container With Most Water]]></title>
    <url>%2F2017%2F10%2F16%2F11-Container-With-Most-Water%2F</url>
    <content type="text"><![CDATA[Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. 题意是说选两条边界，使到这两条边界和X轴组成的容器能够装更多的水。 最简单的就是暴力，枚举所有的i,j边界，但是会超时。所以就得思考O（n）的解法。 容积=h*w。 而且根据短板原理，h是由height[i]和height[j]这两条边界的最低边来决定的。 所以，一开始我们令w最大，即两个边界分别取最左和最右。 接下来更新，不断地缩小w，那么要是到容积变大，那么只能让h更高才行，也就是只要替换掉height[i],height[j]这两个边界中最短（即h）的那个。 所以更新时 12345//替换掉height[i],height[j]这两个边界中最短（即h）的边界while (height[i] &lt;= h &amp;&amp; i &lt; j) i++;while (height[j] &lt;= h &amp;&amp; i &lt; j) j--; 完整代码： 1234567891011121314151617class Solution &#123;public: int maxArea(vector&lt;int&gt; &amp;height) &#123; int len = height.size(); int i = 0, j = len - 1; int maxWater = 0, h; while (i &lt; j) &#123; h = min(height[i], height[j]); maxWater = max(maxWater, h * (j - i)); while (height[i] &lt;= h &amp;&amp; i &lt; j) i++; while (height[j] &lt;= h &amp;&amp; i &lt; j) j--; &#125; return maxWater; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5. Longest Palindromic Substring]]></title>
    <url>%2F2017%2F10%2F16%2F5-Longest-Palindromic-Substring%2F</url>
    <content type="text"><![CDATA[Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example: 1234567&gt; Input: &quot;babad&quot;&gt;&gt; Output: &quot;bab&quot;&gt;&gt; Note: &quot;aba&quot; is also a valid answer.&gt;&gt; Example: 1234&gt; Input: &quot;cbbd&quot;&gt;&gt; Output: &quot;bb&quot;&gt; 题意很简单：找最长回文串 一开始想到的想法就是把s反转为s’，然后找s和s’的最长共同子串。所以问题又转化成了经典的LCS（LongestCommonString）。 最长公共子串LCS 用动态规划来解决LCS问题相对比较简单。时间复杂度是O（n^2），空间复杂度也是O（n^2）。思路如下： 令dp(i,j)来表示以s1[i],s2[j]结尾时两个串目前最长的共同字串。 当i,j都非第一个字符时，考虑此时s1[i]==s2[j]是否成立 若成立，则dp(i,j) = dp(i-1,j-1) + 1 （即二维表左上角格子数值加上1） 若不成立，则dp(i,j) = 0 当i,j有一个为首字符（即 i==0||j==0 ）时，依旧考虑s1[i]==s2[j]是否成立 若成立，dp(i,j) = 1 （因为前面没有字符了） 若不成立，dp(i,j) = 0 用longest来维护整个过程的最大值 具体实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//// Created by chaopengz on 2017/9/20.//#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;public: string longestPalindrome(string s1) &#123; int dp[1005][1005]; string s2 = ""; for (int l = s1.size() - 1; l &gt;= 0; l--) &#123; s2 += s1[l]; &#125; int lenS1 = s1.size(), lenS2 = s2.size(); int longest = 0, endi; for (int i = 0; i &lt; lenS1; ++i) &#123; for (int j = 0; j &lt; lenS2; ++j) &#123; if (i &amp;&amp; j) &#123;//不在首行和首列的时候 if (s1[i] == s2[j]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; else &#123; dp[i][j] = 0; &#125; &#125; else &#123;//首行和首列初始化 if (s1[i] == s2[j]) &#123; dp[i][j] = 1; &#125; else &#123; dp[i][j] = 0; &#125; &#125; if (dp[i][j] &gt; longest) &#123; longest = dp[i][j]; endi = i; &#125; &#125; &#125; string res = ""; for (int k = 0; k &lt; longest; ++k) &#123; res += s1[endi--]; &#125; return res; &#125;&#125;; 以上代码过了样例，但是交上去却发现WA了。 对比LeetCode给出的出错的输入数据，发现上面的想法是有瑕疵的。例如下面的例子： s1=”abcdfcba” 这样子反转后为： s2=”abcfdcba” s1和s2的最长公共子串为abc，但是abc并不是回文串，那么问题出在哪儿了呢？最主要就是在s2找出的共同子串并不在s1对应的位置上。所以，需要对上述想法进行修正加强，在更新最长子串时，要判断这个子串是否在s1对应的位置上，即 1s1[i - dp[i][j] + 1] == s2[j] 完整AC的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: string longestPalindrome(string s1) &#123; int dp[1005][1005]; string s2 = ""; for (int l = s1.size() - 1; l &gt;= 0; l--) &#123; s2 += s1[l]; &#125; int lenS1 = s1.size(), lenS2 = s2.size(); int longest = 0, endi; for (int i = 0; i &lt; lenS1; ++i) &#123; for (int j = 0; j &lt; lenS2; ++j) &#123; if (i &amp;&amp; j) &#123;//不在首行和首列的时候 if (s1[i] == s2[j]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; else &#123; dp[i][j] = 0; &#125; &#125; else &#123;//首行和首列初始化 if (s1[i] == s2[j]) &#123; dp[i][j] = 1; &#125; else &#123; dp[i][j] = 0; &#125; &#125; if (dp[i][j] &gt; longest &amp;&amp; s1[i - dp[i][j] + 1] == s2[j]) &#123;//更新的时候要加强条件，判断是否为s1和s2对应的子串 longest = dp[i][j]; endi = i; &#125; &#125; &#125; string res = ""; for (int k = 0; k &lt; longest; ++k) &#123; res += s1[endi--]; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3. Longest Substring Without Repeating Characters]]></title>
    <url>%2F2017%2F10%2F16%2F3-Longest-Substring-Without-Repeating-Characters%2F</url>
    <content type="text"><![CDATA[Given a string, find the length of the longest substring without repeating characters. Examples: Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3. Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1. Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequenceand not a substring. 题意是给你一个字符串，找出里面最长字符不重复的子串（注意不是子序列）。 刷这道题导致停了好几天LeetCode.可能是一开始就被它只有百分之二十几的通过率给吓到了。就觉得超出自己能力了，所以想了一想然后就果断看了大神的代码。但是，悲催的是，看了之后还是很难以理解，尽管代码只有区区9行，其中关键的也就是只有三行。 终于在今天下午看懂了这道题的思路，其实看破了也不会很难，可能自己智商这几天已经不在线了吧。0-0 其实，这道题既然要最长字符不重复的子串，因为子串相对于子序列而言是连续的，所以只遍历一遍，然后把字符串切割为几段字符不重复的子串，然后找一个变量maxLen维护目前最长的就好了。具体如下图： 所以关键就是在于怎么把字符串切割为几段字符不重复的子串了并记录长度了。 用start来表示每个子串的起始位置，然后逐个逐个往前遍历，当发现遍历到的这个字符已经在当前子串存在了，就将start挪到这个位置，重新计算新的子串。 那么，问题又来了，怎么判断这个字符已经出现在当前子串当中了呢？ 做法是采用hash的思想，将每个字符都映射到它在字符串的位置，当发现这个遍历到的这个字符的value（也就是它在字符串的index）比start大，那就说明它是存在当前子串当中的。 最后用一个maxLen来维护整个过程中划分的子串的最大值即可。 12345678910111213141516class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; dict(256, -1); int maxLen = 0, start = -1; for (int i = 0; i != s.length(); i++) &#123; if (dict[s[i]] &gt; start) start = dict[s[i]]; dict[s[i]] = i; maxLen = max(maxLen, i - start); &#125; return maxLen; &#125; &#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2. Add Two Numbers]]></title>
    <url>%2F2017%2F10%2F16%2F2-Add-Two-Numbers%2F</url>
    <content type="text"><![CDATA[You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 题意将两个数用链表逆序表示，然后求这两个之和，最后结果同样用逆序表示。 一开始我的想法是把两个链表表示的数都转化为int，然后求和，再将结果用逆序链表来表示。但是交了发现WA了，原因主要是爆了int了，即使是后来改成了long long也同样爆了边界。所以断定此思路正在施工，走不通。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; int num1 = 0, num2 = 0, sum; int powTime = 0, powResult; while (l1) &#123; powResult = 1; for (int i = 0; i &lt; powTime; ++i) &#123; powResult *= 10; &#125; num1 += l1-&gt;val * powResult; powTime++; l1 = l1-&gt;next; &#125; powTime = 0; while (l2) &#123; powResult = 1; for (int i = 0; i &lt; powTime; ++i) &#123; powResult *= 10; &#125; num2 += l2-&gt;val * powResult; powTime++; l2 = l2-&gt;next; &#125; sum = num1 + num2; auto *res = new ListNode(sum % 10); ListNode *pre = res, *now = nullptr; sum /= 10; while (sum) &#123; now = new ListNode(sum % 10); pre-&gt;next = now; sum /= 10; pre = now; &#125; pre-&gt;next = nullptr; return res; &#125;&#125;; 然后就发现其实因为链表已经逆序了，所以刚好符合我们加法时从个位往高位逐位相加的原则，只不过改成了下个节点进位而已。所以思路相同了就开始写代码。 但是在写得过程还是有些费劲的，首先得分成以下两种情况 l1,l2刚好长度相等 如果最高位加完不需要进位，则运算完成 如果最高加完需要进位，则需要新建一个节点来保存1 L1,l2长度不相等 这种情况就需要先写个循环将进位处理完 判断最高位是否仍然需要进位 需要的话还要多建一个节点 不需要的话直接然长的链表剩下的节点链接到主链上去即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//// Created by chaopengz on 2017/9/12.////Definition for singly-linked list.struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(nullptr) &#123;&#125;&#125;;class Solution &#123;public: ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) &#123; ListNode *res, *node, *pre; int jinwei = 0; int sum = l1-&gt;val + l2-&gt;val + jinwei; jinwei = sum / 10; res = new ListNode(sum % 10); pre = res; l1 = l1-&gt;next; l2 = l2-&gt;next; while (l1 &amp;&amp; l2) &#123; sum = l1-&gt;val + l2-&gt;val + jinwei; node = new ListNode(sum % 10); pre-&gt;next = node; jinwei = sum / 10;; pre = node; l1 = l1-&gt;next; l2 = l2-&gt;next; &#125; // l1,l2都为空了，如[5]+[5] if ((!l1) &amp;&amp; (!l2)) &#123; if (jinwei) &#123; node = new ListNode(1); pre-&gt;next = node; &#125; &#125; else &#123; if (l1) &#123; while (jinwei &amp;&amp; l1) &#123; sum = l1-&gt;val + 1; node = new ListNode(sum % 10); jinwei = sum / 10; pre-&gt;next = node; pre = node; l1 = l1-&gt;next; &#125; if (jinwei) &#123; node = new ListNode(1); pre-&gt;next = node; &#125; else &#123; pre-&gt;next = l1; &#125; &#125; else &#123; while (jinwei &amp;&amp; l2) &#123; sum = l2-&gt;val + 1; node = new ListNode(sum % 10); jinwei = sum / 10; pre-&gt;next = node; pre = node; l2 = l2-&gt;next; &#125; if (jinwei) &#123; node = new ListNode(1); pre-&gt;next = node; &#125; else &#123; pre-&gt;next = l2; &#125; &#125; &#125; return res; &#125;&#125;; 按照上面这个思路确实可以把代码也正常AC了，但是代码稍微有点冗长，白板写起来很容易错。 所以在看了discussion大神们写得精简代码中选了一个解决方法如下。 相比自己的代码多了一个链表的头指针PreHead，这样就可以结果的第一个节点的运算写进循环里而不需要单独写在循环外。 只要l1,l2,和进位（extra）任何一个不为空都要执行加法，然后将加完的结果添加到主链表。这里它采用了前导0的做法，当l1或l2为空，就取值为0，即最高位补零的做法。l1？l1-&gt;val:0 , l2?l2-&gt;val:0，l1?l1-&gt;next:l1，l2?l2-&gt;next:l2。采用前导零的好处就是不用再像前面自己写的代码那样分析l1,l2长度相等怎么样，不相等又怎么样，极大地减少的代码量。 123456789101112131415161718192021222324** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode preHead(0), *p = &amp;preHead; int extra = 0; while (l1 || l2 || extra) &#123; int sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + extra; extra = sum / 10; p-&gt;next = new ListNode(sum % 10); p = p-&gt;next; l1 = l1 ? l1-&gt;next : l1; l2 = l2 ? l2-&gt;next : l2; &#125; return preHead.next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1. Two Sum]]></title>
    <url>%2F2017%2F10%2F16%2F1-Two-Sum%2F</url>
    <content type="text"><![CDATA[Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 123456&gt; &gt; Given nums = [2, 7, 11, 15], target = 9,&gt; &gt;&gt; &gt; Because nums[0] + nums[1] = 2 + 7 = 9,&gt; &gt; return [0, 1].&gt; &gt; &gt; 题意是给出一个数组和一个目标数，而且在数组中一定存在两个数加起来之和等于目标数。让你求出数组中加起来等于目标数的两个数的索引。 我想到的就是O（N^2）的算法，有点类似于冒泡排序，两层循环遍历，判断是否a[i]+a[j] == target，如果成立的话就把索引i,j返回。 1234567891011121314151617181920212223//// Created by chaopengz on 2017/9/12.//#include &lt;vector&gt;using namespace std;class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target) &#123; vector&lt;int&gt; res; for (int i = 0; i &lt; nums.size() - 1; ++i) &#123; for (int j = i + 1; j &lt; nums.size(); ++j) &#123; if (nums[i] + nums[j] == target) &#123; res.push_back(i); res.push_back(j); &#125; &#125; &#125; return res; &#125;&#125;; 上面的做法虽然可以ac,但是由于是O（n^2）的做法，时间效率较低。其实利用c++的map的索引查找可以达到更快的做法O（nlog(n)）。 首先依旧是对数组进行遍历，取出一个数a[i]后，剩下则是在map中寻找target-a[i]这个数所对应的索引，最后返回即可。 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res; map&lt;int, int&gt; numToIndex; int findNum; for (int i = 0; i &lt; nums.size(); ++i) &#123; findNum = target - nums[i]; if (numToIndex.find(findNum) != numToIndex.end()) &#123; res.push_back(numToIndex[findNum]) ; res.push_back(i); &#125; numToIndex[nums[i]] = i; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[669. Trim a Binary Search Tree]]></title>
    <url>%2F2017%2F10%2F16%2F669-Trim-a-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R &gt;= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree. Example 1: 123456789101112131415&gt; &gt; &gt; Input: &gt; &gt; &gt; 1&gt; &gt; &gt; / \&gt; &gt; &gt; 0 2&gt; &gt; &gt;&gt; &gt; &gt; L = 1&gt; &gt; &gt; R = 2&gt; &gt; &gt;&gt; &gt; &gt; Output: &gt; &gt; &gt; 1&gt; &gt; &gt; \&gt; &gt; &gt; 2&gt; &gt;&gt; &gt;&gt; &gt; &gt; Example 2: 123456789101112131415161718192021&gt; &gt; &gt; Input: &gt; &gt; &gt; 3&gt; &gt; &gt; / \&gt; &gt; &gt; 0 4&gt; &gt; &gt; \&gt; &gt; &gt; 2&gt; &gt; &gt; /&gt; &gt; &gt; 1&gt; &gt; &gt;&gt; &gt; &gt; L = 1&gt; &gt; &gt; R = 3&gt; &gt; &gt;&gt; &gt; &gt; Output: &gt; &gt; &gt; 3&gt; &gt; &gt; / &gt; &gt; &gt; 2 &gt; &gt; &gt; /&gt; &gt; &gt; 1&gt; &gt; &gt; &gt; &gt; &gt;&gt; &gt; 题意是想对一个搜索二叉树进行裁剪，使到所有的节点的值都在[L,R]之间，对于不在[L,R]范围的则减掉该支。 还是对树的结构不熟悉，由于刚刚做了一个树的层次遍历题637. Average of Levels in Binary Tree ,所以这道题也就是想着用层次遍历的思想，层次遍历每个节点，然后判断这个节点的值是否在[L,R]之间，如果不在的话就把该节点置为nullptr。但是发现这种思路还得维护每个节点父节点，比较麻烦想不出来。 再看了Discussion之后发现用递归解决还是很简答的。 判断root的节点是否小于L，如果是，则只有root右子树的值才有可能在[L，R]之间，所以只需要返回root的右子树进行剪裁（递归）后的根节点 同理，判断root的节点是否大于R，如果是，则只有root左子树的值才有可能在[L，R]之间，所以只需要返回root的左子树进行剪裁（递归）后的根节点 左节点为对左子树裁剪后的子树（递归） 右节点为对右子树裁剪后的子树（递归） 1234567891011class Solution &#123;public: TreeNode *trimBST(TreeNode *root, int L, int R) &#123; if (root == nullptr) return nullptr; if (root-&gt;val &lt; L) return trimBST(root-&gt;right,L,R); if (root-&gt;val &gt; R) return trimBST(root-&gt;left,L,R); root-&gt;left = trimBST(root-&gt;left,L,R); root-&gt;right = trimBST(root-&gt;right,L,R); return root; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[637. Average of Levels in Binary Tree]]></title>
    <url>%2F2017%2F10%2F16%2F637-Average-of-Levels-in-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array. Example 1: 12345678910&gt; &gt; Input:&gt; &gt; 3&gt; &gt; / \&gt; &gt; 9 20&gt; &gt; / \&gt; &gt; 15 7&gt; &gt; Output: [3, 14.5, 11]&gt; &gt; Explanation:&gt; &gt; The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].&gt; Note: The range of node’s value is in the range of 32-bit signed integer. 题意是想求一颗二叉树每一层节点的平均值。 其实本质上就是一个层次遍历。虽然最后写出了代码，但仍然是在参考了discussion后自己才能明白的。说明对树的深度优先与宽度优先的的确确很陌生了。 宽度优先（BFS）的处理过程大概如下： 先将根节点放入队列 在队列非空的时候循环 每一次循环开始看一下目前的队列有多大，此时的队列大小即是对应这一层的节点数目多少。 遍历这一个层次的所有节点，从队列取得值，并且在其左右子树非空的情况下将左右子树放入队列，作为下一层的节点。最后将该节点弹出。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;double&gt; averageOfLevels(TreeNode* root) &#123; queue&lt;TreeNode *&gt; q; vector&lt;double&gt; res; //先将根节点放入队列 q.push(root); double sum; int s; //在队列非空的时候循环 while (!q.empty()) &#123; sum = 0; //此时的队列大小即是对应这一层的节点数目多少 s = (int) q.size(); //遍历这一个层次的所有节点 for (int i = 0; i &lt; s; ++i) &#123; TreeNode *node = q.front(); sum += node-&gt;val; //左右子树非空的情况下将左右子树放入队列，作为下一层的节点 if (node-&gt;left) q.push(node-&gt;left); if (node-&gt;right) q.push(node-&gt;right); //从队列弹出 q.pop(); &#125; res.push_back((double) sum / s); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[463. Island Perimeter]]></title>
    <url>%2F2017%2F10%2F16%2F463-Island-Perimeter%2F</url>
    <content type="text"><![CDATA[You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island. Example: 123456789&gt; &gt;[[0,1,0,0],&gt; &gt; [1,1,1,0],&gt; &gt; [0,1,0,0],&gt; &gt; [1,1,0,0]]&gt; &gt;&gt; &gt;Answer: 16&gt; &gt;Explanation: The perimeter is the 16 yellow stripes in the image below: &gt;&gt; 题意就是说有多个相互接壤的土地连成一个岛，然后求这个的岛的周长 思路也很简单，但是自己一开始采用了错误的做法（一直想用一行的周长规律去推整个岛的周长规律），导致一直WA。 其实只要数一数有多少条边是共享（包括行和行共享与列和列共享）的就可以了，每一条共同边会让周长减去2，所以最后答案就可以表达为 4 x 总块数 - 2 x 共同边数。 Wrong Answer版本： 12345678910111213141516171819202122232425class Solution &#123;public: int islandPerimeter(vector&lt;vector&lt;int&gt;&gt; &amp;grid) &#123; int m, n; m = (int) grid.size(); n = (int) grid[0].size(); int countOfLandOfOneRow, countOfLandOfPreRow = 0, perimeter = 0; for (int i = 0; i &lt; m; ++i) &#123; countOfLandOfOneRow = 0; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] == 1) countOfLandOfOneRow++; &#125; if(countOfLandOfOneRow) &#123; perimeter += 2 * countOfLandOfOneRow + 2; perimeter -= 2 * min(countOfLandOfOneRow, countOfLandOfPreRow); countOfLandOfPreRow = countOfLandOfOneRow; &#125; &#125; return perimeter; &#125;&#125;; Accepted版本 123456789101112131415161718192021class Solution &#123;public: int islandPerimeter(vector&lt;vector&lt;int&gt;&gt; &amp;grid) &#123; int m, n; m = (int) grid.size(); n = (int) grid[0].size(); int countOfLand = 0, landSharedOfTwoRows = 0, landSharedOfTwoCols = 0, perimeter; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] == 1) countOfLand++; if (i &gt; 0 &amp;&amp; grid[i][j] + grid[i - 1][j] == 2) landSharedOfTwoRows++; if (j &gt; 0 &amp;&amp; grid[i][j] + grid[i][j - 1] == 2) landSharedOfTwoCols++; &#125; &#125; perimeter = 4 * countOfLand - 2 * (landSharedOfTwoCols + landSharedOfTwoRows); return perimeter; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[557. Reverse Words in a String III]]></title>
    <url>%2F2017%2F10%2F16%2F557-Reverse-Words-in-a-String-III%2F</url>
    <content type="text"><![CDATA[Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example 1: 12345&gt; &gt; &gt;Input: &quot;Let&apos;s take LeetCode contest&quot;&gt; &gt; &gt;Output: &quot;s&apos;teL ekat edoCteeL tsetnoc&quot;&gt; &gt; &gt;&gt; &gt; &gt;&gt; &gt; &gt; Note: In the string, each word is separated by single space and there will not be any extra space in the string. 题意说的是需要将一个字符串中的每个单词进行反转。 我想到的思路比较纯粹。 先将字符串切分成逐个的单词 对逐个单词进行反转操作，即以中间字符作为对称轴对称交换 对反转后单词进行拼接，还原成一个字符串 其中比较难得是第一项，因为c++并不像Python那样，并没有可以直接调用string的split方法就能将字符串切割成单词的优势。所以就在网上寻找c++的string的切割方法，最后发现其实都是手动切割的。就抄了一个代码比较精简的切割方法。 而且，这道题在提交代码之后出现之后出现了RuntimeError，Google了之后才发现是自己的代码写得有漏洞，没有考虑到vector为空的情况。因为vector.size()返回的是一个无符号整数，一旦size为0，那么再继续-1之后就会溢出，造成错误！所以调用size()再减一的时候一定要判断size是否为0，避免再次出错。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: string reverseWords(string s) &#123; //字符串切割，切割后的单词存在v中 vector&lt;string&gt; v; //指定空格为分隔符 string c = " "; std::string::size_type pos1, pos2; pos2 = s.find(c); pos1 = 0; while (std::string::npos != pos2) &#123; v.push_back(s.substr(pos1, pos2 - pos1)); pos1 = pos2 + c.size(); pos2 = s.find(c, pos1); &#125; if (pos1 != s.length()) v.push_back(s.substr(pos1)); string result = ""; //对vector是否为空进行判断，避免出现RuntimeError if (v.size() == 0) return result; //对切分后的逐个单词进行反转，以中间字符为对称轴进行前后交换 char temp; for (int i = 0; i &lt; v.size(); ++i) &#123; for (int j = 0; j &lt; v[i].size() / 2; ++j) &#123; temp = v[i][v[i].size() - j - 1]; v[i][v[i].size() - j - 1] = v[i][j]; v[i][j] = temp; &#125; &#125; //将反转好的逐个单词拼接回字符串 for (int i = 0; i &lt; v.size() - 1; ++i) &#123; cout &lt;&lt; v[i] &lt;&lt; endl; result += v[i] + " "; &#125; result += v[v.size() - 1]; return result; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[617. Merge Two Binary Trees]]></title>
    <url>%2F2017%2F10%2F16%2F617-Merge-Two-Binary-Trees%2F</url>
    <content type="text"><![CDATA[Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Example 1: 1234567891011121314151617&gt; &gt; &gt; Input: &gt; &gt; &gt; Tree 1 Tree 2 &gt; &gt; &gt; 1 2 &gt; &gt; &gt; / \ / \ &gt; &gt; &gt; 3 2 1 3 &gt; &gt; &gt; / \ \ &gt; &gt; &gt; 5 4 7 &gt; &gt; &gt; Output: &gt; &gt; &gt; Merged tree:&gt; &gt; &gt; 3&gt; &gt; &gt; / \&gt; &gt; &gt; 4 5&gt; &gt; &gt; / \ \ &gt; &gt; &gt; 5 4 7&gt; &gt; &gt;&gt; &gt; &gt;&gt; &gt; &gt; Note: The merging process must start from the root nodes of both trees. 题意是要将两棵旧树进行合并新的一棵树。 合并的规则是这样子的，如果两棵旧树对应的节点上都有值得话，那么合并后得到的新树对应节点的则为两个旧树的对应节点的和，如果两颗旧树有一棵对应节点值为空，那么合并后的新树对应节点值则为有值那棵旧树对应节点的值。 虽然在LeetCode上这是一道easy的题目，但是因为自从保完研后基本就没有看过数据结构了，对于树的结构已经很陌生了。所以自己想了许久却无从下手，大概知道需要用到递归。 最后是在看了大神们的解决方法后，思考和回忆了一会才看懂了解题思路。大题如下： 令两颗旧树分别为t1,t2。 首先处理t1,t2都非空的情况（即t1&amp;&amp;t2为真），新建一个树节点root，节点值为t1,t2对应节点值之和。然后对root的左子树和右子树递归调用合并函数。root的左子树由t1左子树和t2左子树合并而成，同理，root的右子树由t1右子树和t2右子树合并而成，最后返回合并的root节点。 然后处理t1和t2有节点为空（有一个为空或者两者都为空）的情况，如果t1不为空，则返回t1，如果t1为空，则返回t2。即t1?t1:t2 1234567891011121314151617181920212223242526// Definition for a binary tree node.struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;&#125;;class Solution &#123;public: TreeNode *mergeTrees(TreeNode *t1, TreeNode *t2) &#123; //t1,t2都非空 if (t1 &amp;&amp; t2) &#123; TreeNode *root = new TreeNode(t1-&gt;val + t2-&gt;val); //合并生成root的左子树 root-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left); //合并生成root的右子树 root-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right); return root; &#125; else &#123; //t1和t2有节点为空 return t1 ? t1 : t2; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[461. Hamming Distance]]></title>
    <url>%2F2017%2F10%2F16%2F461-Hamming-Distance%2F</url>
    <content type="text"><![CDATA[The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note:0 ≤ x, y &lt; 2^31. 海明距离，我想到的办法就是最笨也就是简单的办法，就是用两个数组来存储x,y对应的二进制序列，之后再对数组遍历比较不同的位数，从而得到答案。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int hammingDistance(int x, int y) &#123; int bitsOfA[32]; int bitsOfB[32]; for (int i = 0; i &lt; 32; ++i) &#123; bitsOfA[i] = 0; bitsOfB[i] = 0; &#125; int j = 0; //x十进制转化为二进制，倒序 while (x &gt; 0) &#123; bitsOfA[j++] = x % 2; x = x / 2; &#125; j = 0; //x十进制转化为二进制，倒序 while (y &gt; 0) &#123; bitsOfB[j++] = y % 2; y = y / 2; &#125; //遍历寻找不同位数，得到答案 int number = 0; for (int k = 0; k &lt; 32; ++k) &#123; if (bitsOfA[k] != bitsOfB[k]) &#123; number++; &#125; &#125; return number; &#125;&#125;; 然而，这道题使用位运算会更加简便。因为是寻找二进制不同位数，所以只需要数数n=x^y得到的二进制数上有多少个1即为答案。 再计算n的二进制上1的个数用的是一个循环，当n不为0时循环，重点在 n &amp;= n - 1，执行这个“与”运算后会把n对应的二进制最右边的1转化为0。每转化一次dist++，当所有的1都转化为0后dist就为最终答案。 1234567891011class Solution &#123;public: int hammingDistance(int x, int y) &#123; int dist = 0, n = x ^ y; while (n) &#123; ++dist; n &amp;= n - 1; &#125; return dist; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
</search>
